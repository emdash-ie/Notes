{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Arithmetic for Computers\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Operations on Integers\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Addition and subtraction\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Dealing with overflow\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Multiplication and division\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Addition\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overflow if result out of range\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab if adding two positive operands and the result sign bit is 1\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab if adding two negative numbers and the result sign bit is 0\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab none if adding a positive and a negative operand\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Subtraction\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Add negation of second operand.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overflow if result out of range\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab subtracting positive from negative and result sign bit is 0\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab subtracting negative from positive and result sign bit is 1\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab none if subtracting two operands of same sign\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Dealing with Overflow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some languages (e.g. C, Java) ignore overflow.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use MIPS {\f1 addu}, {\f1 addui}, {\f1 subu} instructions\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 'u' stands for unsigned\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other languages (e.g. Ada, Fortran) require raising an exception.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use MIPS {\f1 add}, {\f1 addi}, {\f1 sub} instructions\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab on overflow, invoke exception handler\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Save PC in exception program counter (EPC) register\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Jump to predefined handler address\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 mfc0} (move from coprocessor reg) instruction can retrieve EPC value, to return after corrective action\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Multiplication\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab You can multiply as if in decimal and just read the answer as binary.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Product is allocated length equal to the sum of operand length.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Faster Multiplier\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use multiple adders\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab cost/performance tradeoff\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Can be pipelined\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab several multiplications performed in parallel\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 MIPS Multiplication\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two 32-bit registers for product:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab HI: most-significant 32 bits\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab LO: least-significant 32 bits\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Instructions:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 mult rs, rt} or {\f1 multu rs, rt}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 64-bit product in HI/LO\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 mfhi rd} / {\f1 mflo rd}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Move from HI/LO to rd\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Can test HI value to see if product overflows 32 bits\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Division\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Faster Division\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Can't use parallel hardware as in multiplier.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Subtraction is conditional on the sign of the remainder\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Faster dividers generate multiple quotient bits pre step\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab still require multiple steps\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab solution current uses future prediction and correction strategy\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 MIPS Division\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use HI/LO registers for result\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab HI: 32-bit remainder\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab LO: 32-bit quotient\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Instructions\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 div rs, rt} / {\f1 divu rs, rt}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab No overflow or divide-by-0 checking\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab software must perform checks if required\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Use {\f1 mfhi} and {\f1 mflo} to access result\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Floating-point Real Numbers\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Representation for non-integral numbers (including very small and very large numbers).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Like scientific notation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 General form: {\f1 \u177?1.xxxxxx_2 * 2^yyyyy^}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Binary points (rather than decimal points)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are {\f1 float} and {\f1 double} in C. This will be explained later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Floating-point Standard\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Defined by IEEE in Std 745-1985 (in 1985).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Developed in response to divergence of representations \u8211- portability issues for scientific code.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now almost universally adopted.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two representation:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Single precision (32-bit)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Double precision (64-bit)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 x = (-1)^S^ * (1 + Fraction) * 2^(Exponent - Bias)^\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab S is the sign bit (0 for non-negative, 1 for negative)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Significand is {\f1 1 + Fraction}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Exponent: excess representation: actual exponent + bias\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab ensures exponent is unsigned\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab single: bias = 127\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab double: bias = 1203\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The bias was brought in to help sorting (?) as e.g. -1 contains mostly 1s and so looks very large, while +1 contains mostly 0s and looks very small [check this].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Floating-point Range\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Exponents {\f1 11111111} and {\f1 00000000} are reserved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So the actual smallest value is 1 - 127, which gives -126.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So the smallest value is \u177?1.0 * 2{\super -126} = [check].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The largest value is \u177?2.0 * 2{\super 127} = 3.4 * 10{\super 38} in decimal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Floating-point Example\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Represent -0.75:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Subtract powers of 2 (from +0.75 and negate the answer) - each one subtracted corresponds to a 1 in the correct column of the binary result\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Alternatively, multiply the remainder by 2 and keep subtracting the same power of 2 (2^-1, which is 0.5).\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab You have to track which column you're on.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This is equivalent to long division by 2.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Subtract 0.5 from 0.75 \u8211-\u160?this corresponds to 0.1 in binary.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The remainder is 0.25.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Subtract 0.25 from the remainder \u8211- this corresponds to 0.01 in binary.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The remainder is 0.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Since the remainder is 0, we're done. The answer is 0.11 in base 2.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Alternative:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Subtract 0.5 from 0.75 \u8211-\u160?this corresponds to 0.1 in binary.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The remainder is 0.25.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Multiply the remainder by 2 \u8211- this gives 0.5.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Subtract 0.5 from the remainder \u8211- because of our multiplying by 2 this corresponds to 0.01 in binary.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The remainder is 0.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Since the remainder is 0, we're done. The answer is 0.11 in base 2.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Floating-point Addition\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Convert the values to binary\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Align the decimal points (remember each shift corresponds to multiplying or dividing by 2)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Add the numbers\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Keep the power (which should now be the same)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Normalise the result and check for over-/under-flow\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Round and renormalise is necessary\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Floating-point Adder Hardware\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Much more complicated than an integer adder.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Doing a calculation in one cycle isn't possible.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab If you slow down the clock to fit FP operations, you'll slow all instructions down\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Instead, calculations take multiple clock steps\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab They can also be pipelined\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Floating-point Multiplication\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In decimal:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Add exponents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Multiply significands\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Normalise result\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Round and renormalise if necessary\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 5.\tx360\tab Determine sign of result from signs of operands\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In binary:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Add exponents (unbias them first)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Multiply significands\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Normalise result and check for over-/under-flow\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Round and renormalise if necessary\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 5.\tx360\tab Determine sign of result\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 FP Multiplicator Hardware\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Similar in complexity to FP adder.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Uses a multiplier for significands instead of an adder\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab FP arithmetic hardware usually does:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab additions, subtraction, multiplication, division, reciprocal, square-root\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab floating point to integer conversion (and back)\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Operations usually take several cycles\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Can be pipelined\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Floating-point Instructions in MIPS\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are separate floating-point registers:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 32 single-precision registers: $f0 \u8230? $f31\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use two neighbouring ones together for double-precision\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Floating point operations only work with floating-point registers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are also separate load and store instructions [check these].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Single-precision arithmetic:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 add.s}, {\f1 sub.s}, {\f1 mul.s}, {\f1 div.s}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g. {\f1 add.s $f0, $f1, $f6}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Double-precision arithmetic:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 add.d}, {\f1 sub.d}, {\f1 mul.d}, {\f1 div.d}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g. {\f1 mul.d $f4, $f4, $f6}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Single and double-percision comparison:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 c.eq.s}, {\f1 c.lt.s}, {\f1 c.le.s}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 c.eq.d}, [\u8230?]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab These set or clear a floating-point condition bit\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Brach on floating-point condition:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 bc1t}, {\f1 bc1f}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab branch if the condition bit is true, branch if the condition bit is false\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [Note: need to look up {\f1 lwc1} and {\f1 lwc2}.]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Accurate Arithmetic\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are extra bits for precision (guard, round, and sticky).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These allow you to choose rounding modes, which allows you to control what's happening in the intermediate stages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Not all FP units implement all options, though. Most programming languages and FP libraries just use the defaults.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Floating-points have limited size (precision). These limits must be remembered and programs must be written accordingly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Subword Parallelism\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Designed to address multimedia applications\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Graphics and audio applications can take advantage of performing simultaneous operations on short vectors using parallelism.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g. 128-bit adder can simultaneously perform:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab sixteen 8-bit adds\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab eight 16-bit adds\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab four 32-bit adds\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is also called data-level parallelism, vector parallelism, or SIMD (single instruction, multiple data).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 x86 FP Architecture\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Based on 8087 FP coprocessor\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Used a push-down stack\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Intel provided 128-bit extension register for FP operations\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab four single-precision numbers (since a single-precision operation uses 32 bits)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab two double-precision numbers\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab In 2011 Intel doubled the width to 256 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Single operation can support 8 single-precision operations\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Pitfalls\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Left shift multiplies by 2. However, right shift only divides by 2 for unsigned integers\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For signed integers, an arithmetic right shift replicates the sign bit.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Doesn't give the right division result\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Associativity Pitfall\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Parallel programs may interleave operations in unexpected orders, so associativity may not hold.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This is a problem where you're combining large numbers and small numbers\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Floating Point Accuracy\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Intel Pentium FDIV bug in 1994\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Even small inaccuracies can be a big problem\sa180\par}
}
