{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 System Performance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One measure is the response time/execution time \u8211- how long it takes to do a task.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another is the throughput \u8211- the total work done per unit time (e.g. tasks per hour). This is especially important for servers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We'll focus on the response time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Adding a faster processor affects both, but adding more processors affects throughput more.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Relative Performance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Define this as 1 / the execution time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now we can represent "X is n times as fast as Y" more naturally.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Measuring Performance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 Elapsed Time} is the total time to complete a task:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Includes Processing, I/O, OS overhead, Idle time\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 CPU Time} is the time spent processing a given job.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Doesn't include I/O time or time spent on other jobs in the middle.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Made up of the user CPU time and the system CPU time.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Different programs are affected differently by CPU and system performance.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 CPU Clocking\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The operation of digital hardware is governed by a constant-rate clock \u8211- everything happens on clock steps.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The clock period is the duration of a clock cycle.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The clock frequency is the number of cycles per second, and is the inverse of the period.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The CPU execution time for a program is the number of clock cycles multiplied by the time each cycle takes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can represent this as: # of cycles / clock rate.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Performance can be improved by:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab reducing the number of clock cycles\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab increasing the clock rate\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hardware designers often need to trade off clock rate against cycle count.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The number of clock cycles can be found by multiplying the number of instructions (the instruction count) by the number of cycles per instruction (the CPI).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So we can redefine the CPU Time as (Instruction Count x CPI) / Clock Rate.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The instruction count for a program is determined by the program, the ISA, and the compiler.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The average CPI is determined by CPU hardware. If different instructions in a set have different CPIs, then the average CPI is affected by the balance of those instructions.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Performance in General\par}
{\pard \ql \f0 \sa180 \li0 \fi0 CPU Time = (Instructions per program) x (Clock cycles per instruction) x (Seconds per clock cycle)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Performance depends on:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Algorithm: Affects IC, possibly CPI\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Programming language: affects IC, CPI\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Compiler: affects IC, CPI\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ISA: affects IC, CPI, Tc\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Time is the only reliable measure of performance.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Power Trends\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Clock rates increased until 2004, with the pentium 4 processor, which had a clock rate of 3600. However, this had a huge power consumption, and the heat made it behave erratically, so since 2004, clock rate has been staying roughly the same, while power consumption has been decreasing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The dominant IC technology is CMOS, and the power consumption is given by this equation:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Power = Capacitive load x Voltage^2 x Frequency\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Recently, we've been keeping the power low by decreasing the voltage (from 5V to 1V). It's difficult to make ICs work below 1V, though.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Once we've hit the power wall, it makes sense to move to multiprocessors.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Multiprocessors\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Multicore multiprocessors\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Require more than one processor per chip\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This requires explicit parallel programming\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Compare with instruction level parallelism, where the hardware executes multiple instructions at once, which is hidden from the programmer\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Requires knowledge of the architecture\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This is hard to do:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab programming for performance\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab load balancing\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab optimising communication and synchronisation\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Benchmarks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Benchmarks are used to tell the difference between processors when you haven't actually tried them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 SPEC Power Benchmark\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Power consumption of servers at different workload levels.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Calculate the performance at each 10% increment\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note that the power is not proportional to the load for servers.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We're trying to design this at the moment though, as that would save energy and make it easier to manage energy consumption.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Servers work well at 100%.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab The best servers around the world typically work only at 50%, though.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some of the reason for higher power use than expected at low load is power leak from transistors, which are now very small.\par}
}
