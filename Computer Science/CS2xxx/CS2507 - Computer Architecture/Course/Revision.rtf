{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Intro\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab don't just focus on what we're revising now \u8211- everything is important\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab slides might not be online, to prevent people from focusing on them too much\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Overview\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab fundamentals of computer design\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab hardware/software interface\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab program performance and how it can be improved\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab hardware techniques to improve performance\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab hardware techniques to improve energy efficiency\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab instruction set principles\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab pipelining\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab memory hierarchy\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab parallel processors\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Computer Architecture \u8211- 8 Great Ideas\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 1.\tx360\tab Design for Moore's Law\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab design for rapid change\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab design process for computer takes a long time, so predict rapid change\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 2.\tx360\tab Use abstraction to simplify design\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab representing hardware and software at different levels\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 3.\tx360\tab Make the common case fast\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab easier to improve on simple cases than complex ones\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 4.\tx360\tab Performance via parallelism\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab parallel operations are faster\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 5.\tx360\tab Performance via pipelining\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab sequential pattern of parallelism\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 6.\tx360\tab Performance via prediction\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab operating based on healthy guess\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab cost of misprediction important\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 7.\tx360\tab Hierarchy of memories\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab arranging memory according to cost/fastness\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab memory the main limitation on the program speed (since the processor is faster)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 8.\tx360\tab Dependability via redundancy\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab including redundant components for addressing failure\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab parallel processors\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Hardware/Software \u8211- Program Translation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab application software (top)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab written in high-level languages (far from machine language)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab system software\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab compiler: translates HLL code to machine code\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab assembler the first type of translator (not compiler?)\sa180\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab operating system: service code\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab handling I/O\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab managing memory and storage\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab scheduling tasks & sharing resources\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab hardware (bottom)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab processor, memory, I/O controllers\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Levels of Program Code\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab high-level language\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab level of abstraction closer to problem domain\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab provides for portability and productivity\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab assembly language\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab symbolic representation of machine instructions\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab human-understandable\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab hardware representation\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab bits\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab encoded instructions and data\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: diagram with assembler, compiler, linker, loader important \u8211- learn to reproduce it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Computer Components\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab classic components:\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab inputs\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab outputs\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab memory\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab processor (datapath and control units)\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Same components for all kinds of computer (desktop, server, supercomputer, embedded system).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Inside the Processor\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab datapath\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab performs operations on data\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab control\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab sequences datapath, memory access\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab cache memory\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab small fast SRAM memory for immediate access to data\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Understanding Performance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Number of things matter:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab algorithm\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab determines number of operations executed\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab programming languages, compiler, architecture\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab determine the number of machine instructions executed per operation\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab I/O system (including OS)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab determines how fast I/O operations are executed\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab processor and memory system\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab determine how fast instructions are executed\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 System Performance\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab response time:\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab how long it takes to do a task\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab aka. execution time\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab important for personal mobile device\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab throughput\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab total work done per unit time\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab e.g. tasks/transactions per hour\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab focus of servers\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 How are response time and throughput affected by:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab replacing the processor with a faster version?\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab adding more processors?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Measuring Performance\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab elapsed time\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab total time to complete a task, including all aspects (processing, I/O, OS overhead, idle time)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab determines system performance\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab CPU time\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab time spent processing a given job\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab does not include I/O time or other jobs' shares\sa180\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab user CPU time and system CPU time\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab different programs are affected differently by CPU and system performance\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 CPU Performance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 CPU time = CPU clock cycles * clock cycle time = CPU clock cycles / clock rate}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab important to be able to reproduce this\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Performance is improved by:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab reducing number of clock cycles\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab increasing clock rate\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hardware designer must often trade off clock rate against cycle count.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 MIPS\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Stanford MIPS commercialised by MIPS Technologies (www.mips.com)\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Large share of embedded core market\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab typical of many modern ISAs\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab Intel x86\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab ARMv7\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab this and v8 mostly mobile devices\sa180\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab ARMv8\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Arithmetic Operations\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab add and subtract, three operands\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab two sources and one destination\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab {\f1 add a, b, c      # a gets b + c}\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab all arithmetic operations have above form\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab design principle 1: simplicity favours regularity\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab regularity make implementation simpler\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab simplicity enables higher performance at lower cost\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Register Operands\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab arithmetic instructions use register operands\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab every operand must first be in a register\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab MIPS has a 32 x 32-bit register file\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab used for frequently accessed data\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab numbered 0-31\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab 32-bit data called a word\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab assembler names\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab $t0 \u8211- $t9 for temporary values\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab $s0 - $s7 for saved variables\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab for saving state (on stack) when calling another procedure\par}
{\pard \ql \f0 \sa180 \li1080 \fi-360 \bullet \tx360\tab automatically saved when you call another procedure (or possibly just when {\f1 push} command is used?)\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab design principle 2: smaller is faster\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab MIPS has a small number of registers, and they're not that big\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab desire to maintain fast clock cycle time\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Translation of C code to MIPS (and vice-versa) will be on the exam.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Memory Operands\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Main memory is used for composite data (arrays, structures, dynamic data).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To apply arithmetic operations:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab load values from memory into registers\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab store result from register to memory\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Important to note that memory is byte-addresses in MIPS (each address identifies an 8-bit byte).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Words are aligned in memory:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab address must be a multiple of 4\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 MIPS is big-endian:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab most-significant byte at least address of a word\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 lw $t0, 32($s3)\line
add $s1, $s2, $t0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 MIPS R-Format Instructions\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Fields for register-format instrutions:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 op}: 6 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab operation code\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 rs}: 5 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab first source register number\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 rt}: 5 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab second source register number\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 rd}: 5 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab destination register number\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 shamt}: 5 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 funct}: 6 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab [\u8230?]\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 MIPS I-Format Instructions\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab immediate arithmetic and load/store instructions\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab {\f1 rt} is destination or source register number\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab {\f1 constant} can be positive or negative in two's complement\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab allows {\f1 addi} to do subtraction\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 op}: 6 bits\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 rs}: 5 bits\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 rt}: 5 bits\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 constant or address}: 16 bits\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Procedure Calling\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab procedure allows programmers to concentrate on a portion of a task at a time\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab includes parameter to interface to the rest of the program\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab steps required for calling procedure\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 1.\tx360\tab place parameters in registers\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 2.\tx360\tab transfer control to procedure\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab backs up saved registers first\sa180\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 3.\tx360\tab acquire storage for procedure\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 4.\tx360\tab perform procedure's operations\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 5.\tx360\tab place result in register for caller\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 6.\tx360\tab return to place of call\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A leaf procedure is one that doesn't call another.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A non-leaf procedure calls others (or can call others).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Floating Point\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab representation for non-integer numbers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab including very small and very large numbers\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Like scientific notation:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab -2.34 x 10^56\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In binary:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab \u177?1.xxxxx_2 * 2^yyyy\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab x's called binary points (rather than decimal points)\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab normalised form has only one digit in front of the decimal point, and that digit isn't a zero\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Used for {\f1 float} and {\f1 double} types.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 IEEE Floating Point Format\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 x = (-1)^s * (1 + Fraction) * 2^(Exponent - Bias)}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab exponent affects range\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab fraction affects precision\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Operations always a tradeoff between precision and range.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Exponent: excess representation: actual exponent + bias\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab bias makes exponents all unsigned\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Important to know how to convert floating point numbers to binary.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Floating-point Addition & Multiplication\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab numbered steps\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Instruction Execution\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab two basic steps:\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 1.\tx360\tab PC -> instruction memory\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab fetch instruction\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 2.\tx360\tab Register numbers -> register file\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab [\u8230?]\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Depending on instruction class, use ALU to calculate:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab arithmetic result\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab memory address to load/store\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab branch target address\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also access data memory for load/store\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Put the target address or the address of the next instruction on the program counter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Building a Datapath\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Datapath is the elements that process data and addresses in the CPU\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab e.g. registers, ALUs, muxes, memories\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We will build a MIPS datapath incrementally\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab [\u8230?]\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab the longest execution path determines the clock period\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab critical path: load instruction\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab instruction memory -> register file -> ALU -> data memory -> register file\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab not feasible to vary period for different instructions\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab pipelining improves throughput but not latency\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Hazards\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Multiple Issue\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Memory\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab principle of locality (temporal & spatial)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Memory Hierarchy Levels\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab block is the unit of copying \u8211- may be multiple words\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 DRAM Technology\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab tries to couple refreshing, reading, and writing together to be more efficient\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Direct Mapped Cache\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 N-Way Associative\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Fully Associative\par}
}
