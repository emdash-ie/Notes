{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Scheduling\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Historically, the CPU is allocated to one process until its completion (batch processing). After this period of time, the CPU was time-shared by multiple processes ready to execute. As the CPU is time-shared, processes compete for the next available time slot.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The scheduler is the kernel process that implements an algorithm that decides which process gets the CPU next.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The scheduling process needs to be fair to all processes.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Processes ready to execute are organised in a queue (the ready to execute queue), from which the scheduler selects the next one.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A process takes control of the CPU by having its state restored, after the state of the previous process is saved.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A process can have control of the CPU for at most one time slice (represented by {\f1 tau} seconds).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The execution time of the scheduler should be very short, as it needs to operate just on the boundary of a time slice.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The execution time of the scheduler shouldn't depend on the number of processes to execute. (Should be a constant-time operation.)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Uses a binary vector with one flag per process (in Linux) to ensure this.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Scheduling Strategies\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 First-Come First-Served (FCFS a.k.a. Round Robin)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Processed are getting CPU control in their order in the queue.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab One possibility is to have control of the CPU until the process finishes \u8211- non-preepmtive execution. This may lead to starvation of other processes.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab So the best solution is to time-share the CPU. [more here]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 Example: shortest process first\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the CPU isn't time-shared (and so is batch-processed), the order in which processes are scheduled is important. * Processes can be ordered according to their execution time. * If processes get control in the increasing value of their execution time, the average turnaround time is better than in the random order. * turnaround time is the waiting time + the execution time * average turnaround time is the sum of turnaround times for each process, divided by the number of them * important for admin \u8211-\u160?gives a measure of how long a process will stay in the system until its completion * the time consumed from the moment the process is ready for execution until its completion.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Say you have four processes with their completion times in brackets: a(50), b(60), c(20) and d(45).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In that order, the turnaround times will be: 50, 110, 130, 175.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The average turnaround is then 465/4.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If you order them as shortest-first, the turnaround times become: a(115), 175, 20, d(65).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab To do this though, you need to know the execution times of all the processes, and you need to know that they'll all start at the same time.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab These characteristics exist in embedded systems.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Priority Scheduling\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab processes are different, some interactive and some computationally demanding.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The time for some is dominated by I/O, and for some is dominated by CPU time.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A process with no I/O can't be switched to a blocked state(?)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So we assigned a priority to processes. This is an integer \u8211- the lower the value, the higher the priority.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab kernel processes have higher priority than user processes\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab give fast, interactive processes higher priorities\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab historically, the priority was assigned in advance, but nowadays processes can have their priorities changed at runtime\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab this can happen when a process has to wait a long time for an I/O operation with a hard drive\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The priority is increased once the operation is finished.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This can also happen with a CPU-intensive operation\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab If it gets a couple of time slices to itself, the priority may be decreased to allow access for other processes\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 Multilevel Feedback Queues\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Several queues, each associated with a priority level. Initially each process gets a priority that puts it on a certain level.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab After consuming each time-slice, the process priority is lowered to the next level, until it reaches the lowest acceptable priority. At that level, the strategy is round-robin.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab [more here]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Generally we have at most 4-16 queues/priority levels.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab With sensors and embedded systems, we have at most 4.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For each process, we have a highest acceptable priority and a lowest acceptable priority.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs16 A Process for Power Management\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many systems have an idle process, which has the lowest priority. When there is no other process to execute, the CPU is given to the idle process, which switches the system into sleep state(s), to manage power consumption.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The idle process implements the kernel power policy manager, which owns the decision-making and the set of rules used to determine the appropriate frequency/voltage operating state. It may make decisions based on several inputs, such as end-user power-policy, processor utilisation, battery level, or thermal conditions and events.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The processor driver is used to make actual state transitions on the kernel power policy manager's behalf.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note the idle process can be quite complex, because of the amount of input parameters. Also a sleep state wouldn't involve just the CPU, but also other hardware components.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The system needs to switch back to the active state when there are new processes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 MFQ (cont.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As well as the priority changing at runtime, there can be a different time-slice size for each priority level, where low-priority levels get much larger time slices, as they are tasks which take longer. This is often increased exponentially for lower priority levels, e.g. the time-slice for level i might be q*2{\super i}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If a process didn't complete at level i, then its priority is lowered and its time-slice is increased.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs16 Two-Level Scheduling\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sometimes, there are too many processes that can't fit in main memory at the same time. So some will have be stored on the disk. But the process of restoring the process in the main memory while others are saves on the disk is time-consuming \u8211- this can lead to thrashing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One solution is to use two-level scheduling:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab a higher-level, long-term scheduler that runs more slowly (maybe every n time-slices) will select the subset of processes resident in the main memory\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab processes in the main memory are then managed by a different scheduler, lower-level and short-term\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 99% of the time, only the short-term scheduler is running \u8211- the other is only launched when the system is struggling.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs16 Real-time Scheduling\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Keeps doing the same thing forever until you switch it off.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Event-driven systems \u8211-\u160?system responds to events signalled by interrupts.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Mostly short processes\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Have to meet deadlines\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. {\f1 a} has to happen every 400 time units, {\f1 b} every 500 time units, {\f1 c} every 700 units, {\f1 d} every 900 units.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Say we have those processes, and each will execute in less than the time slice of 100 time units.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In general we can pick the ones with the earliest deadlines first. When things have the same earliest deadline, we need another priority to choose which one. Could be whichever one had control longest ago.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs16 Multi-Core Systems\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A package is two cores and one L2 cache.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab On each core we can have processes that are totally independent of one another, or processes that belong to the same application.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab If they belong to the same application, then they share data.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We can also have different threads of the same process.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab These share everything (code, data, etc)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab All of this shared stuff needs to be stored in L2.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In hardware, L2 is split into a number of blocks, and access is by a grid. Cores can't access the same block at the same time. So they can't access the exact same data at the same time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We can't eliminate contention, but we can reduce it by designing well.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First scheduling policy: group scheduling\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Put processes together that share data (and possibly code) - these processes are said to have affinity for one another.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many multi-core systems are mobile devices powered by batteries, so energy usage is important and must be managed. With multiple packages, we have to decide at any time whether we should use all packages, or keep one in a sleep state to save energy. If execution time is not important, the scheduler will choose to use just one package, and won't turn on the second. This is the second scheduler policy.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All cores don't have to be loaded to the same degree \u8211- some can be overloaded and some can be underloaded. We can define an average load, which is the boundary between under- and over-loaded.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If one core is overloaded and one is underloaded, we want to move processes from one to the other \u8211-\u160?this is load balancing. This is a new attribute of the scheduler specific to multi-core systems.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What is load? We can define it as the amount of time spent busy in a certain period of time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The third scheduler policy is domain scheduling.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This is a hardware perspective, concerned with resources.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A domain is a group of cores that share the same specifications and share the same load-balancing and scheduling policies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We can create hierarchies of domains. Say level 1 is any package used alone in a four-package system. Say level two is two packages used at once, and level 3 is all packages used.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For level 1 we have 4 domains\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Level 1 is a two-core system\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For level 2 we have 2 domains\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Level 2 is a four-core system\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For level 3 we have 1 domain\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Level 3 is an 8-core system\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We can have different scheduling policies then for each domain.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For level 3 we might say that if a package has low load, we'll switch it off and distribute tasks to other processes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This would be an energy-saving policy\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For level 2 we might use load-balancing for a policy (balance the load across cores in each domain)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab We can have different policies in different domains of the same level\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For level 1 we might say "if exec: move to another core" (this also mentioned for level 3)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Alternatively, on one particular domain we might pair processes that are CPU-intensive (but use little memory) on one core and processes that are memory-intensive (but use little CPU) on the second core.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With this process we're creating virtual machines:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 1 with 8 cores\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 2 with 4 cores each\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 4 with 2 cores each\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The scheduler has prior info about processes:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Memory access patterns\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Resources that are required\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It gets this info from previous executions (collects runtime info), or it can use heuristics to anticipate resource usage.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Scheduling (cont.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Different operating systems may implement these scheduling principles in different ways, or may not implement all of them. Group and domain scheduling are popular.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 UNIX\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Primitive calls\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 fork()} creates a new process that is an exact copy of the parent process\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 exec()} replaces the code of the existing program with a new one\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 exit()} allows a process to voluntarily terminate\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 kill()} allows a process with appropriate privilege to terminate another process\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 wait()} allows a process to pause until a child process has finished, and pick up its exit status\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Process States\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to running, blocked, and ready, there are a few additional states:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 SSLEEP} \u8211- a blocked state where the process cannot be awakened by a signal\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 SWAIT} \u8211- a blocked state that allows the process to be awakened to handle a signal\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 SRUN} \u8211- Identifies running and ready processes. The {\f1 u} variable contains the process table info of the currently running process\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 SIDL} \u8211- a process is created but the copy of its parent's memory space can not be done immediately\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 SZOMB} [\u8230?]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Process Table\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The process table uses some flags to record the status of the process in respect to memory (the process is in memory or swapped out) and tracing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The process table is divided in two:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The first part is an array of structures as part of the kernel space. These structures hold admin info, state info, id, scheduling info.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The other part is data not needed when the process is swapped out, and is part of the user space. User structures are swapped along with the rest of the process' memory space \u8211- this is to preserve space.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Scheduling\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The scheduler uses process priorities. The actual scheduling code is in the context\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab priority is dynamically updated:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 p = min(127, c/(16 + 100 + n))}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 n} is a parameter called nice \u8211- if this increases, the priority lowers\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab two-level scheduler\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 TinyOS\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Very simple compared to what we've seen with a general purpose computer. There are many other OSes for sensors, but this one is interesting because it shows how simple and basics things can be.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It's also very similar to OSes for internet of things devices.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Tasks, events and commands execute in the context of the frame and operate on its state.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab CPU typically 8 or 16 bits\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Processor typically 4 MHz\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Memory in KB\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab No virtual memory, segmentation, or paging\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Energy has to be managed as tightly as possible.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Computation has to be very fast\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Communication has to be done as seldom as possible.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We have sensors deployed in the environment, which create sensor networks that are used to push sample data towards a server. The server does storage.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each sensor works as a router, as well as doing its sampling work.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The OS must have a footprint of KBs or less in main memory. Remember the memory here is just a plain location, addressed simply. No files, no virtual memory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Modular system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is an OS for tiny sensors that provides a set of system SW components. Only the necessary parts of the OS are compiled with the application, meaning each application is built into the OS.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An application wires OS components together with application-specific components \u8211-\u160?a complete system consists of a scheduler and a graph of components.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A component has four interrelated parts:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A set of command handlers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab commands are input\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab generally target tasks\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A set of event handlers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab events are input\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A fixed-size frame\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A bundle of tasks\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The component may also be a source of events or of commands.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A task is not a process \u8211- we don't have the concept of a process here.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A task defines a computation that corresponds to some function.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g.:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 get ADC data} \u8211- get data from the ADC (from the sensor)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 send packet} \u8211- for communication\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At most 10/20 instructions.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab All tasks execute until completion.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab unless there is an event\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab events interrupt tasks that are currently in execution\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab control is taken by that event handler\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Event handlers do very simple things. Generally they "post" tasks \u8211- pushing them into the ready queue. The only other things they do are small things, e.g. incrementing a counter or assigning a local variable.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab events can be interrupted by other events\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When the ready queue is empty, the core is switched to a sleep state, but the sensors aren't, as they still need to act as a router.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The whole system is a graph of components.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab some of these are OS components\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab timer, radio, routing, etc.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab some are application-specific\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab sensors and specific processing\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Commands can't trigger events, because that could create cycles.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If a task is posted but there's no space in the ready queue (in TinyOS v1), it fails. Since the queue is a shared resource, one misbehaving component can ruin everything.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In version 2, now tasks have priorities, and the scheduler can run earliest deadline first. The order of execution can be changed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One byte of state is allocated per task, this gives us 255 possible priority levels \u8211- it's assumed there's less than 255 tasks in the system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A basic post will fail if and only if the task has already been posted and has not started execution.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 TinyOS Timer\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Different sensors can have very different sampling periods (a few seconds, a few hours).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Field Monitor Application\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sampling takes time, and with the task/event structure, the CPU doesn't have to be waiting for the data. The task can be {\f1 get ADC data; return immediately}, and then the CPU will send the command to the ADC and then continue with the next task. When the data is ready in the ADC, an event will be sent to tell the CPU that the data is ready.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember that energy consumption for communicating (e.g. by radio) is orders of magnitude greater than energy consumption in the rest of the system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The units onscreen are all software, except the RFM, the ADC, and the HWClock. As a designer, we wouldn't see these as hardware but as components that we can use in our application.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Active Messages\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The message includes the destination handler and nothing else (besides the message itself). This keeps things simple.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We don't have to transport layer, we don't have the protocol stack (IP, TCP) from the internet.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Main\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The main is just for initial setup (e.g. variable initialisation), it's not involved after that, so no events ever need to go to the main.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note there's no monitoring of the sensors to make sure they're ok and still working.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Android\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The concept was that the handheld is the new PC, so we need a complex general purpose OS.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, android also includes non-OS things like middleware and applications. Applications like the phone, the messages, etc. are basic and built-in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 He'll focus on activity and intent and how activities are managed in Android on Monday.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Android\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab kernel, middleware services, applications\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab (extends beyond a classic operating system)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab has its own JVM (Dalvik VM)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab shares components and data among applications\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab applications reuse components from one another\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab a process may skip some components\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab execution flow can jump from one process to another\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab this is inter-process communication (IPC)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab (possibly just on the same component)\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab this is an event-driven operating system, rather than a general-purpose operating system\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab for general-purpose system, all interaction is by commands\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab for this, the operating system may respond to user events if it has the resources\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab [check difference between general-purpose OS and event-driven OS]\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab applications have a non-visible part to their lifecycle\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Android Applications\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Applications don't have a single entry point for everything in the application (no {\f1 main()} function, for example). They have components that the system can instantiated and run as needed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An {\i intent} is an amalgamation of ideas such as windowing messages, actions, inter-process communication, publish/subscribe models and application registries.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Intents define intention to do some work (e.g. broadcast a message, start a service, launch an activity, dial a phone number, answer a call). They can also be used by the system to notify the application of specific events (e.g. arrival of a text message).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Views} are UI elements that can be used to create a user interface.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An {\i activity} is a UI concept. Usually it represents a single screen in the application. It can contain one or more views.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Content providers} allow to expose data to sharing by multiple applications.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i service} is a background process, either local or remote.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Lifecycle\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The android application lifecycle is managed by the system based on the user needs, available resource, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The system decides if an application can be loaded or it is paused or stopped.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The activity currently used (has visibility) get higher priority, while an activity not visible can be killed to free resources.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each android application runs in a separate process which hosts its own virtual machine. [dynamically changing priority, etc]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onCreate()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> {\f1 onStart()}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onStart()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> {\f1 onResume()}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onResume()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> Running -> {\f1 onPause()}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab another activity comes in front of the activity\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onPause()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> {\f1 onResume()}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab the activity comes to the foreground\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> {\f1 onStop()}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab the activity is no longer visible\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> killed -> {\f1 onCreate()}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab other applications need memory\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab user navigates back to the activity\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onStop()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> {\f1 onDestroy()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> {\f1 onRestart()}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab the activity comes to the foreground\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab -> killed -> {\f1 onCreate()}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onRestart()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 onStart()}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 onDestroy()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab shut down\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If a user interacts with an application, that application gets the highest priority.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Tasks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With IPC (e.g. we want to display a street map from GPS), we are starting a task following the user's commands.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A task is a sequence of activities that make the execution flow.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The fact that you're allowed go from one process to another is very different from general purpose OSes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Task Stack\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A task is a stack of activities. The top of the stack contains the current activity.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If a new task is started, the previous one is saved and switched to the background. So the stack is preserved, but is not the running task. It's still in the memory. We may have more than one stack that's in the background at once. Activities in the stack are never re-arranged, just pushed and popped.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the system needs resources, it can delete activities from the stacks, or delete whole stacks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is how different applications are kept available to the user.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Linux\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Processes and threads are tasks. (Different from android tasks).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 System Calls\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are nearly 300 system calls, many related to process management:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 fork()}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 vfork()} is a variation on {\f1 fork()} that eliminates the copy of the parent memory space in the case where {\f1 fork()} is quickly followed by an {\f1 exec()} call. The child uses the parent memory space until invoking {\f1 exec()}. The parent is suspended this time.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 clone()} allows specification of which of the parent's resources are to be shared with the child and which are to be copied.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab specification is with clone flags\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 execve()} allows a process to specify a program to begin running in place of the current one.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab [more here]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Scheduler Calls\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 sched_setscheduler()} allows a process with enough privileges (system) to change the policy and priority level the scheduler uses for the specified process [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Process State\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_RUNNING\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_INTERRUPTIBLE\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_UNINTERRUPTIBLE\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_STOPPED\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_TRACED\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_ZOMBIE\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab still consuming resources?\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TASK_DEAD\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Process Creation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 fork()}, {\f1 vfork()}, and {\f1 clone()} all call {\f1 do_fork()}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab if it's {\f1 vfork()}, the parent needs to be suspended\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab the parent will return to ready when the child calls {\f1 exit()} or {\f1 exec()}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the child can be in a stopped or ready state initially\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 alloc_pid()} is called to give the child a process id\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab this will try to use {\f1 last_pid + 1}, but it will have to check that it's not in use\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab this searching could be very slow, so a bit vector is used \u8211- the first 0 that's found gives the new PID\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The parent can return to ready if the call came from {\f1 fork()} or {\f1 clone()}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Linux Scheduler\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This gives preference to interactive processes and processes with lower {\f1 nice} values.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab two multilevel feedback queues \u8211- one for active processes, one for expired processes\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab uses a bitmap to quickly determine which queue is the highest priority nonempty one [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two classes of process:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab real-time (RT)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab these are scheduled according to SCHED_FIFO or SCHED_RR (round robin).\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab first-in-first-out processes will always complete\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab round-robin ones will return but with the same priority\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab these are processes which generally don't use a full time-slice\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab time-sharing\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab these work as described before\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Priorities\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Real-time processes have a static priority in the range [0, 99].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Time-sharing processes have a priority in the range [-20, 19]. Internally they are scaled to the range [100, 139].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Smaller values correspond to higher priorities.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Remember each priority level is a queue. If a real-time process from a round-robin queue doesn't complete, it'll return to the end of the queue it came from.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [check all of this bit, lots of info here]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If there are no more time-sharing processes in the active structure, the time-sharing parts of the active and expired structures are swapped.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 tick()} is a system call which checks what a core is running.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab if the core is idle, it might rebalance the load from other cores\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab if the current process is from the expired set, this is considered an error\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab this can happen if there are no active processes left and no swap occurred to swap the active processes with the expired processes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab it's an error because we only want active processes to have controller\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 The Linux Scheduler\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab runs in constant time because it uses a bit vector (where each bit is set if and only if there are processes waiting in the corresponding queue) to check which process to run\sa180\par}
}
