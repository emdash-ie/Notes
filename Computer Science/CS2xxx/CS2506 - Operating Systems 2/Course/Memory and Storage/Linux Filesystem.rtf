{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Meta\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab will finish the course next week\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab then a week of practice\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab then a week of review\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If there's anything you'd like to be covered/discussed more, let him know.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Intro\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Questions at the beginning are what is covered.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 The Virtual Filesystem\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab main concept used by linux\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is a layer of abstraction - sits on top of any physical filesystem.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Exposes to applications a number of common services and generic file operations.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab organised as a collection of base classes, one for each area of file system activity.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab manages kernel-level file abstractions in one format for all file systems\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab receives system call requests from user level (e.g. write, open, stat, link) and resolves them\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab based on the information brought in when a system is mounted\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab interacts with a specific file system based on {\f1 mount point traversal}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab receives requests from other parts of the kernel, mostly from {\f1 memory management} and {\f1 process management}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For each VFS service, the specific file system has a structure containing function pointers defining the operations it provides.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab keep a datastructure with pointers to the relevant functions in the underlying filesystem\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab brought in when mounted\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab VFS and underlying filesystems exist in the kernel space\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab requires a lot of memory, which is why it didn't exist in older operating systems\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Main Components\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 superblock}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab information about the mounted filesystem (metadata)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 inode}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab information about a specific file\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 file}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab information about an open file\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 dentry}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab information about a directory entry\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All files are part of a directory, and there are entries in a d_node which map the filename onto a specific inode. Superblocks are stored on the disk, and inodes point to them.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Superblocks\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When a filesystem is mounted, a FS-specific function is called to load an internal representation of the FS metadata. Named after the original UNIX on-disk metadata, this is called the superblock.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A member of the internal superblock structure points to a structure of type {\f1 struct super_operations}. This structure contains a number of function pointers that are needed to carry out operations on a mounted FS.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Although the name suggests that these functions are primarily related to superblocks, they're actually more related to managing inodes. (~)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Superblock gives info about inodes. (?)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Superblock Data Structure\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Total number of inodes\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab file system size in blocks\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab free block counter\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Inode Structure\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An inode represents an individual file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some interesting structure members:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 alloc_inode()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab allocate the memory for and initialise an in-memory inode structure\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 read_inode()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab read an inode from the FS\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One member points to a structure which contains function pointers for operations with specific files and directories. (~)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Directories are implemented as lists of directory entries. The VFS maintains in the main memory a cache of directory entries that provides a mapping from file names to inodes. They can be quickly searched to avoid unnecessary disk accesses. (This is a heavy load on memory, along with everything else.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to the inode operations, the internal inode structure also points to a structure of type struct file_operations. When a file is opened, an internal structure representing the open file is created. This structure points to file operations [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Everything from the diagram at the beginning is brought into memory. For a large filesystem, this is a heavy load on memory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 The EXT3 Filesystem\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Probably the most-used in Linux.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In any disk or partition with this filesystem, the first block is reserved for boot. The next block is a superblock, which is replicated in several places in the FS. (block size can vary from 1024 to 8192 bytes)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Divides the FS into block groups, each having a copy of the superblock. The following block is a one-block group descriptor table, and then two blocks of free bitmaps \u8211- one for free blocks within the group and one for free inodes within the group. Following are inode blocks. the rest of the blocks are for data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The strategy is to keep the blocks allocated to a file in the same group together with its inode. (In each group, \u8230?)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each entry of the directory structure contains the file name and the i-number. To speed up directory searches, there's an option for adding a hash table to the directory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: ask about how the hash table speeds up the searches.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There's also a journal, which is like a log for what the filesystem has done recently. Used for tracking errors.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 EXT3 Name Lookup\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 open()} system call enters the kernel with the function {\f1 sys_open()}. The major function is to locate the inode that corresponds to the path name passed by the application.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The open sys call checks the permission of the operation with the inode and then builds the internal open file data structure.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 After about seven nested function calls, the VFS function {\f1 _link_path_walk()} is invoked, to follow the path name along the directory tree.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Path can be absolute or relative [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Write Operation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When the file is open, the application can call {\f1 read()} and/or {\f1 write()}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Writing to a file begins by determining the point where writing starts (part of the open file structure). After that, the control is passed to VFS, where the request is checked to make sure that it doesn't violate security (e.g. file open read-only) or other limitations. Then the control is passed to the EXT3 specific write function.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Linux I/O\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In Linux, all device drivers appear as normal files.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are three categories of devices.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are block devices, character devices, and network devices. [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Block Devices\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Block devices provide the main interface to all disks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Unit of transfer is the block \u8211- generally corresponds to one sector.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The request manager manage the reading/writing of the bugger used in a block device transfer. A separate list of requests is stored for each block device driver. This list is maintained in sorted order of increasing starting sector number. A request will be removed from the list after [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Merged if they involve neighbour sectors. [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Disk Organisation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The surface of the disk platter is logically divided into circular tracks that are subdivided into sectors. The set of tracks that are at one arm position makes up a cylinder.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The disk is addressed as a one-dimensional array of logical blocks. [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Disk Scheduling\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Important to consider the performance.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The access time = seek time + rotational latency.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The disk bandwidth is the number of bytes transferred divided by the total time between the first request for service and the completion of the last transfer.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Disk scheduling optimises the above metrics by good decisions on the next disk request to be served.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Strategies\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab First come first served (FCFS)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab all requests serviced as they arrive\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab fair but doesn't provide fastest service\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab example: sequence of requests to blocks on cylinders: 42, 211, 234, 19, 87\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Shortest seek time first (SSTF)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab Service all the requests close to the current head position before moving far away\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab may cause starvation for some requests, meaning it is non-optimal\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 SCAN Scheduling\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also known as the elevator algorithm.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The head moves from one end to the other, servicing requests as it reaches each cylinder, then reverses direction, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Assuming a uniform distribution of requests, when the head approaches one end, relatively few requests are in front of it (depends on how space is allocated). The heaviest density at this point is at the other end of the disk.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 C-SCAN (Circular SCAN) tries to provide a more uniform wait time. Everything is the same except when the head arrives at one end it returns immediately to the other end without servicing any requests.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab In practice neither algorithm is implemented as above. The arm only goes as far as the final request in each direction. Then it reverses direction without going all the way to the end of the disk. These are called LOOK and C-LOOK.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Selection of I/O Scheduling Algorithm\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pattern of I/O requests has a substantial impact on the overall performance. E.g. if there's only on erequest, all algorithms behave the same. (Have we many or few requests right now?)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The file allocation strategy is important \u8211- less arm movement if the file is stored contiguously. If the file is indexed (therefore the index is cached in the main memory and it's easy to locate the blocks that belong to the file), the blocks can be widely spread on the disk.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The location of directories and index blocks is also important. We can have the directory on the first cylinder, or on the middle cylinder, the latter generally leading to less arm movement.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Caching directories and index blocks reduces the need for arm movement.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other system operations such as demand paging (bringing into the main memory pages that belong to a (user?) process) have higher priorities than application I/O. If these operations occur frequently, they'll have a significant impact on the operation of the scheduler.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 I/O Scheduling in Linux Kernel\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab read queue, write queue, different deadlines\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Similar to the elevator algorithm but associates a deadline with each request\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab If several requests correspond to neighbour sectors they are merged\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Character Devices\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Any character device driver registered to the kernel must also register a set of functions that implement the file I/O [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Network-attached Storage\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Accessed remotely over the network. Access is by remote procedure call (RPC).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The storage is normally implemented as a RAID array with an RPC interface.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In addition to the physical system, we can have a non-volatile RAM cache for storing data that doesn't lose information if the power is down.\par}
}
