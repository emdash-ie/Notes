{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Storage Space Management\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab free space on disks similar to main memory but also dealing with sectors\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab need to preserve consistency between main memory, cache, and disk\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 \u160?File System Metadata\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Most filesystems have a header. This describes the file system as a whole and gives a starting point for locating files in the system. It includes:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the total size of the filesystem\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the amount of free space\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the date of the last mount\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the location of the free space data structures\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab starting point for any name lookup\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The header can be in a fixed location (e.g. the first block of the disk). But we will probably have many copies of the header (to ensure it doesn't get lost). Locations may store pointers to a common file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 \u160?Disk Structure\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Disk can be divided into partitions.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab RAID is a redundant array of inexpensive disks \u8211- this can be created virtually through partitions\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab multiple copies of things protects against failure and also speeds up access\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A partition can be used raw or formatted with a file system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Partitions are also known as minidisks and slices.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Something containing a file system is known as a volume. [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As well as general-purpose filesystems, there are many special purpose filesystems which are customised specifically for embedded systems. They have specific structure corresponding to the type of data managed by applications.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 * optimised for fastest access to data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Free Space Management\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Unlike main memory, allocation is done in fixed-size blocks (block is typically a multiple of a sector (where a sector is 512 bytes)). Sectors used by a file may not be contiguous.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Can use either a free bitmap or linked lists (embedded in the free blocks) for tracking free memory. Where do we store the free bitmap though? Generally keep a copy in the kernel space in main memory, but then we need consistency. Also, we want to have the disk operating completely separately. If we place it in the middle of the disk, then we can reduce the amount of movement of the write head required to check it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Allocation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Simplest solution is to allocate contiguously. If the file grows, there needs to be enough space after the last block \u8211- if there isn't, the file must be moved to another space.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another option is to allow the file to spread out, but keep the blocks as close as possible.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A linked list can be used to represent the blocks allocated to a file. This list can be a separate data structure, or each pointer to the next block is stored in the current one. If the list is sorted, it should contain only block numbers. It the size of the structure is larger than the block size, the list itself will be distributed on more blocks that point to each other.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another approach is to use an array of pointers, one for each data block in the filesystem \u8211- each entry gives the next block of the file. This still requires a linear search.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To speed up the access time, the index blocks can be organised in a tree \u8211- with 512-byte blocks, the root will store 128 pointers addressing 128 index blocks that each address 128 data blocks, etc. This gives a logarithmic search.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These data structures need to be managed all the time as blocks change around.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 \u160?Directories\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A collection of nodes containing information about all files in the filesystem. (?)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The directory maps a subset of names to file metadata \u8211- size of the file, file ownership, security characteristics, [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A directory is also a file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 \u160?Operations Performed on Directories\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Similar to files:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab search for a file\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab create a file\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab delete a file\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab list a directory\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab rename a file\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab traverse the filesystem\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Directory Models\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab single-level\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab all files are the in the same directory, and must have unique names\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab two-level\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab a separate directory for each user\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab there is the master file directory (MFD) and one user file directory (UFD)\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab tree-structured\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab users can create their own subdirectories\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab one bit in each directory entry defines the entry as a file or as a directory\sa180\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab path is unique: names don't have to be\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab acyclic-graph\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab allows directories to share subdirectories and files [check]\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Implementation of Sharing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In UNIX a new directory entry called {\f1 link} is created \u8211- it's a pointer (absolute or relative path name) to another file or subdirectory. The link is resolved by using the path name to locate the real file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Another implementation is to duplicate the information about the shared resource in all directories sharing it. All directory entries about that file are the same. This solution raises the problem of consistency \u8211- a file can have multiple absolute filenames.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is not as important at the moment, as many people are using co-operative access things like google docs. Several people can write at the same time (usually on their own copies, which are then integrated in some way).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Consistency Checking\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The filesystem checks to see if free blocks are indeed free. This is done periodically or when a mount operation is executed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As this is time consuming, log files can be used \u8211-\u160?for example, when a file is deleted:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab remove the directory entry\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab free the data blocks\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab free the metadata structure\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the system crashes during any of these operations, the file system is left in an inconsistent state. As in databases, the delete operation should be either entirely executed or not. The journal contains enough information to control the operation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Block Caching\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Similar to operation between main memory and cache memory (entire cache line brought in at once).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Transfer between disk and main memory is by whole blocks. The OS reserves memory space for file caches (buffers).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A kernel thread will take care of data synchronisation \u8211- each block in the cache that's marked modified is queued to be written on the disk and then marked as clean.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Synchronisation is also forced when a file system is unmounted.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As the cache space is limited, the problem of block replacement needs to be solved. The strategy used to replace a block is least-recently-used (LRU).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two things to take care of (also described in points above):\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Space management (page replacement in main memory)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Consistency (change will occur in main memory, and should be propagated to the disk)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All data structures involved in storage are copied to the main memory for fast access and processing by the filesystem.\par}
}
