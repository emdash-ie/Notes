{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 In the past, when a new computer was designed, the design process started with a bunch of applications, and tried to optimise the computer according to these applications. This is no longer the case.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Memory\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Unlike the plain-space memory we saw for the sensor OS, in a general-purpose computer we have the memory hierarchy.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Faster access but lower capacity memory closest to the CPU (which is the fastest device in the system).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Slower access and higher capacity memory further from the CPU.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When a variable is brought into the CPU, it leaves multiple copies along the memory hierarchy, which need to be updated if the variable is modified.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Virtual Memory\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Originally programs were restricted by the size of the memory (e.g. if your program needed 65kB but you only had 64, it wouldn't run).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now we have virtual memory, where addresses in a virtual memory space are mapped to some physical address. Originally this was done in software by the kernel, but now we have a dedicated unit called a memory management unit, which carries out this mapping quickly (in hardware).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Many software processes handled by the kernel are being gradually moved to hardware, which is faster.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Memory is a very expensive resource, that needs to be shared between different processes. This is why we need to manage it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The memory addresses issued by the CPU are physical addresses. The process layout is specified in terms of virtual addresses though.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Address Translation\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Base registers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The virtual address is added to the content of a base register \u8211- the result is the physical address\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Compared to a limit\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Can change the content of the base register\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Segmentation\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Dedicated registers for different segments\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Different segments store different parts of the program\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab code\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab data\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab stack\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Possible to use CPU dedicated registers, or the higher-order bits of the VA point\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Still limited for processes\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Paging\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Most flexible concept\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Physical space and virtual space divided into pages of the same size\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Pages in the virtual space are contiguous, but pages in the physical space can be anywhere\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Aim to allocate few pages to a process\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\i Page frame} is any space in the physical memory where page could go\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab If a page is 4 KiB, we need 12 bits (as 2^12 = 4096) for an offset, to address any part of a page\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab VA = virtual address\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab page address and offset within the page\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab page address identifies a row in a page table\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab that row provides the physical location in memory of the corresponding page frame\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab the offset is used to identify a specific address within that page\sa180\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab page table has extra bits \u8211-\u160?control info for the kernel\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab e.g. a read-only marker\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab presence \u8211- is the page in memory or not?\par}
{\pard \ql \f0 \sa0 \li1800 \fi-360 \bullet \tx360\tab e.g. initially when the process starts, not all pages are brought into physical memory\par}
{\pard \ql \f0 \sa0 \li1800 \fi-360 \bullet \tx360\tab so we have some addresses that don't map to physical memory\par}
{\pard \ql \f0 \sa0 \li1800 \fi-360 \bullet \tx360\tab these are allocated physical memory as needed\par}
{\pard \ql \f0 \sa0 \li1800 \fi-360 \bullet \tx360\tab Alternatively, physical memory might be nearly full, and this page was swapped to the disk to make space\sa180\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab modified \u8211-\u160?at least one write operation has occurred in this page\par}
{\pard \ql \f0 \sa0 \li1800 \fi-360 \bullet \tx360\tab only modified pages will be updated on the disk\par}
{\pard \ql \f0 \sa0 \li2160 \fi-360 \endash \tx360\tab would be very expensive to do it for all pages\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab access \u8211- info in this page has been accessed [check]\sa180\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Multi-Level Page Table\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab top-level page table is smaller, and the second-level page tables that we're not currently using don't need to be in memory\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For example:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab 32-bit VA, 4 KiB (= 2{\super 12} bytes) page size\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab 12 bits of VA needed to index the page in bytes\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab other 20 bits of VA split in two:\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab 10 bits used to choose a row in the top-level page table\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab this row tells us which second-level page table to go to\sa180\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab other 10 bits used to select a row in the second-level page table\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If we're only using one page, we need to have the top-level page table in memory, but we only need to have one of the second-level page tables in memory, and the rest can be swapped out.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So we have 2{\super 10} entries in the top-level table and 2{\super 10} entries in the second-level table, giving a total of 2{\super 10} + 2{\super 10} = 2{\super 11} entries. If each entry is 4 bytes, then we have to use 2{\super 11} * 4 = 2{\super 13} bytes = 8 KiB of memory to store the page tables.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If we had one single-level table, the whole thing would need to be in memory at once, so we would need 2{\super 20} * 4 = 4 MiB of memory to store the page table.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using more than two levels provides further saving of space, but access to pages gets slower (already with the two-level table we have to read 3 memory locations instead of 2).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Allocation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 OS provides this memory service to processes in two forms:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab explicit allocation\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab process specifies the location of memory it needs\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab implicit allocation\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab process specifies how much memory but not where it is\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 De-allocation can also be explicit or implicit (when areas not addressed by code are freed).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Memory Layout\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Generally OSes are using segmentation and paging together. There're code segments for pages of code, etc.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Segmentation is preferred for protection \u8211- gives good control of the space allocated to a process, prevents a process from accessing other processes' code.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab But a process can only start if it has a minimum number of pages allocated to it.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If a process only has small chunks of data, it doesn't make sense to waste a whole page.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab There's a block of memory with variable size, allocate blocks of memory to different processes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab A page may not be given to a process, but instead used by the kernel and split into blocks which are allocated to different processes.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This gives rise to security of different processes accessing each other's data\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Used so by processes that share data\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some of the memory space can be non-functional, if there are some memory chips that aren't installed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Memory Management Example\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Blocks are built on top of pages \u8211- each block is a number of pages. The size can be variable.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You could have a bit vector with one bit per page to mark whether a page is available. The kernel can check this vector to find an available page to use.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However processes generally need several pages, not just one or two, so allocation is typically done per block, using blocks of variable size.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We can then organise information about these blocks into a list:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab starting address of the block\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab how many pages the block is (an integer)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab pointer to the next block position\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now searching this list to find an available block is O(n). We could arrange the list as a tree or a hash to speed this up.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The system could learn which sizes are mostly requested by processes, and organise the blocks to optimise for that, or just run as needed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Now we have two possibilities:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab work at the page level\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab work at the block level\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Working like this will give us fragmentation, though \u8211- we'll have memory that isn't used. There are two types:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab internal (when not an entire allocated space is used)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab process only uses 3 KB out of 4 KB in a page\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab external (some blocks are too small to ever be allocated)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Allocation processes try to minimise both kinds of fragmentation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Selection Policies\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 First-fit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Take the first block from the list that is greater than or equal to the requested size. If the request can't be met, it fails.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This tends to cluster allocations towards the low memory addresses \u8211- the low memory area gets fragmented, while the upper memory area tends to have larger free blocks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Next-fit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Start the search (for the next acceptable free block) with the next block after the last allocation, wrap around at the end. If returned to the starting point without allocation, the process fails.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This leads to a more even allocation of free memory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Best-fit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Allocates the free block that is closest in size to the request (very little internal fragmentation).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Tends to create significant external fragmentation, but keeps large blocks available for requests of larger size.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Worst-fit\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Allocate the largest block for each request.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is good if most requests are of similar size, as external fragmentation will be minimised.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 The Buddy System\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All blocks are a power of 2 in size. Let n be the size of the request. Locate a block of at least n bytes and return it to the requesting process:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab If n < the smallest allocation unit, set n to be the smallest size\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Round n up to the nearest power of 2. Select the smallest k such that 2^k >= n.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab If there is no free block of size 2^k then recursively allocate a block of size 2^k+1 and split it into two free blocks of size 2^k.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Return the first free block of size 2^k in response to the request.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each time a block is split, a pair of buddies is created \u8211- they'll either be split or paired together.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab It is easy to determine (by looking at bit k+1) which is the buddy of a block.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This method tends to have very low external fragmentation. The price paid is more internal fragmentation.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The block that is de-allocated is a buddy to a free block \u8211- they are merged in order to create a larger free one.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Advantages\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab small blocks are allocated quickly\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab larger blocks are split in two\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab eventually followed by the merge of the two blocks (the initial block is restored)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab larger blocks size is maintained\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Over-allocation Techniques\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Not all allocated blocks are in use all the time \u8211- seldom used blocks can be transferred to disk.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Swapping} is transferring one blocked process' memory space on disk. When the process becomes active, it'll be restored.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If the process shares code [\u8230?]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Segment/Page Swapping\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There's a presence bit which tells whether the memory space is available on RAM or has been swapped to disk. If the stuff is on disk, the bit triggers an interrupt to retrieve the data from\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If the hardware supports only a limited number of segments (code, data, stack), only those can be swapped. A larger number of segments allow for more memory space to be freed by swapping.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Paging is a similar technique but involves pages correspond to a finer-grained level.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Memory-mapped Files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Within the kernel space, there's memory reserved for buffers. This memory will be allocated as required to speed up some functions.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When a file is requested from storage, a page or two of the file is read into memory in one operation (rather than an individual operation for each sector or reading the entire file at once). Pages are pulled into memory as needed (demand paging).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 From now on, that buffer is reserved for this file. Everything in that buffer can now be accessed very quickly, rather than requiring a read from the disk.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Windows NT Memory Management\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Windows NT uses memory-mapped files (as one way to prevent processes having access to each others' content?).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Page Management\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When a process needs to read a page and is using its max working set size, then the choice of page to be replaced comes from its set.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab General purpose OSes are difficult to optimise because you don't know what kind of applications will be used\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab companies are focusing on optimising their OSes\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Windows NT Page Frame State Machine (diagram)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Linux Memory Management\par}
{\pard \ql \f0 \sa180 \li0 \fi0 3 models:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab use pages\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab use blocks (of variable sizes)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab slab(?) of memory\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab used when some processes need very small amounts of memory (far less than a page, e.g. 64 bytes)\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 System Calls\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab memory-mapped file operation for {\f1 execve()} speeds things up and is more efficient\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab for other system calls, there's no need to do this because the code is already in memory\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Allocation Mechanisms\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab buddy system\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Example\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Main memory: 4 MB page = 4 KB\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This means 1024 pages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 So we decide the first block should be 1 page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The next will be a block of 2 pages, then 4 pages, and so on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 block: 1 page block: 2 pages block: 4 pages \u8230? block: 32 pages\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Say we have a request of size n bytes. We try to find the smallest k such that 2^k >= n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If n is 700 B, then 1 block of one page will be enough.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Say n is 7254 B \u8211- in that case we need a block of 2 pages free. Say there are none free. Then we need to find a block of 4 pages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Once we've found this, we split it in two \u8211- half will be allocated to this process and half will be marked as free.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If we can't find a block of 4 pages, we look for a block of 8 pages. If we've found this, the 8 will be split into two blocks of 4, and one of the blocks of 4 will be split into 2 blocks of 2 pages. One of those will be allocated to the process and one will be marked as free.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When these blocks become free, it's very easy to merge them to make larger blocks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Slab Allocator\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Works similarly to the buddy system, but just for small size (e.g. a few bytes).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Good for reducing internal fragmentation\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Page Management\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab a possibility is to use 4-level page-table design\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab four levels of indirection (4 tables)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab not all levels are used, but that's what the system provides\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab uppermost bits of VA index a page global directory\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab second field is used as a pointer to another page directory\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab finally we get to a page table\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Analysis\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Android uses paging and memory mapping\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab but many mobile systems do not use paging\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab because it's expensive, either in software or in the micro-architecture\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary (Memory Management)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Main memory management means a set of services:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab monitoring free memory\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab this is the basic service provided by the kernel\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab allocation to processes\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab replacement\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab memory mapping\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first 3 can be implemented as individual services or just as one service.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These are used all the time, so implementation is important \u8211-\u160?they need to run quickly.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Security is also important \u8211- guaranteeing that processes can't have their memory space modified by other processes. This isn't covered in this course.\par}
}
