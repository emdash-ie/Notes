{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Bitmaps and Bloom filters\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Bloom filters are probabilistic (answers aren't 100% correct), but very space efficient.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Bitmaps are not practical for large sets.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Bitmaps\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A bitmap represents the members of a given index set. May be represented using a boolean array.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Java doesn't specify how to represent a boolean (it's up to each JVM implementation). If the booleans are represented as ints, this would be a waste of memory, especially if the index size is large.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In practice bitmaps are often represented as int arrays.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Basic Representation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 Bitmap(int capacity)} \u8211- create a bitmap\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Implementation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab probably would be good to make the {\f1 Bitmap} class final\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab that way public methods can't be overridden\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab can allow the compiler to optimise\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab ternary operator use in {\f1 add} and {\f1 remove} is an optimisation because in theory it would allow the two statements to be done in parallel\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab size handled manually to be more efficient\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 {\f1 int} Representation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Manipulating Bits\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab arithmetic method is too slow\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Some Facts\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab operations are constant time under the assumption that array access by index is O(1) \u8211- this is not always the case\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Bloom Filters\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab can't answer questions about size\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab can't remove from the set\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab can improve quality of the answer by increasing the size of the filter a little bit\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Implementation\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab union of bits is numbered from the right\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Application: Detecting Malicious Websites\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab assume we want to know whether a given URL is malicious\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab hash the URL into hash codes {\f1 h_0}, \u8230? {\f1 h_n-1}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab if bit {\f1 h_i} = 0 for some i, then the URL isn't known\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab otherwise the URL is known (but this may be a false positive)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At this point there are two possibilities:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab trust the answer\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab use a slow database operation to see if the URL is known\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This speeds up detection of malicious websites largely if the majority of websites are not malicious. Google uses this.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Application: Probabilistic Spell Checker\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Start with an empty bloom filter B.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For each allowed word, add the word's hash code to B.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Application: Pre-Processing Database Joins\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab computing the join takes a lot of time, and removing redundant rows also takes a lot of time.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab using bloom filters takes us from O(|T1| * |T2|) to O(|T1| + |T2|)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab |T1| is the number of rows in table T1\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Start with an empty bloom filter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For every row in T1, look at the tuples for common attributes, fill bloom filter with it (once per row).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Look at every row in T2, if they're not in the bloom filter we can remove the rows (can also do that with T1).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: {\f1 public int hashCode()} is defined in the Object class. It's generally advised that objects depending on this should override the method to get better performance.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is done in e.g. {\f1 HashSet} in Collections.\par}
}
