{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Objects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Java is an object-oriented language.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Objects have state and behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 State: what objects know\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Behaviour: what objects do\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To implement object state we need to define instance attributes (and assign values to them).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To implement behaviour, we define instance methods.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Constructor ensures a class is equipped with the proper initial state.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The class:instance relationship is a 1:n relationship. Instances of a class may have different state by their instance attributes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are also class attributes \u8211-\u160?every instance of a class have access to the same value. These shouldn't be used to represent instance state.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Polymorphism\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If we have an object reference of type {\f1 Object}, then we can only call methods defined in the {\f1 Object} class, even if the object is, say, an {\f1 Integer}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Call-by-Value\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Very important to understand the call-by-value mechanism.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two types of parameter:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab formal parameters are the parameters inside a method definition\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public void function(int a, String b) \{\line
    // a and b are the formal parameters\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab actual parameters are the values passed to the method in a method call\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 function(1, "hello");\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To call a method with n parameters:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab define n fresh scratch variables (usually on the stack)\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab evaluate the actual parameters from left to right\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab order is important because the expressions in the parameter list may have side-effects, e.g. {\f1 blah(var++, var--)}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab evaluated left-to-right (if var is 2 beforehand), the parameters are (2, 3), evaluated the other way they're (1, 2)\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab the results are assigned to the corresponding scratch variables\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab evaluate the method body using the temporary scratch variables as the formal parameters\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab upon return:\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab if there's a result, substitute it for the method call\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab remove the scratch variables from the stack\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This also happens if you have local variable definitions inside a block:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 // var doesn't exist here\line
int f() \{\line
    int var = 1;\line
    // var exists here\line
\}\line
// var doesn't exist here\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Common Errors\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab using instance attributes instead of temporary variables\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Clazz \{\line
    private int result;\line
\line
    private int f(int arg) \{\line
        result = arg + 3 * arg * arg;\line
        \u8230?\line
        return result;\line
    \}\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab this won't work if f is recursive, for example, because the recursive call will share the same value for {\f1 result} instead of having its own variable\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Should look like this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Clazz \{\line
    private int f (int arg) \{\line
        int result = arg + 3 * arg * arg;\line
        \u8230?\line
        return result;\line
    \}\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab local variables will also be on the stack, which is faster than the part of memory instance attributes will be stored in\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Call-by-Value Simulation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public int fib(int n) \{\line
    int result;\line
    if (n <= 1) \{\line
        result = n;\line
    \} else \{\line
        result = fib(n - 1) + fib(n - 2);\line
    \}\line
    return result;\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Evaluating {\f1 fib(2)}:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab define initial state for the stack:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab create a scratch variable on the stack to hold the argument\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab evaluate the argument\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab put the result into the scratch variable on the stack\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab evaluate the function using the value 2 for {\f1 n}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab have to create space for {\f1 result} on the stack as it's a local variable\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab enter the else clause\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab evaluate {\f1 fib(n - 1) + fib(n - 2)}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab create space on the stack for the parameter for the first call\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab evaluate {\f1 n - 1} and put the result in the parameter on the stack\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Inheritance\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Aim to build a class hierarchy.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In the hierarchy there are superclasses and subclasses \u8211- subclasses inherit from superclasses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A subclass can have no more than one superclass (in Java). A superclass may have several subclasses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The superclass defines the common behaviour by defining public instance methods, and (usually) providing default implementations for these methods.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Subclasses may reuse these behaviours or provide new behaviour by overriding the methods.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Subclasses may also define additional behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Usefulness\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is useful because you can share implementation defined in superclass \u8211- don't have to rewrite the code.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab makes sure any errors only have to be fixed in one place, too\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab subclasses can alter behaviour of methods without breaking other classes that depend on the implementation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab the subclass\u8212-superclass relationship should be an "is-a" relationship, e.g. a cat is an animal\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Abstract Classes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Abstract classes can't be instantiated. This makes sense in an inheritance hierarchy where we want to put common behaviour in a class (e.g. Feline) but we don't want to be able to create instances of that class. Instead we want to create (e.g.) Cats, which are Felines (Cat is a subclass of Feline).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Abstract Methods\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Abstract methods are methods which are not implemented, but must be implemented in subclasses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: methods that are overridden should be preceded by {\f1 @Override}, which checks to make sure you're overriding a method (catches typos)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Final Classes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A final class is a class that can't be subclassed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many built-in classes are final, so that their behaviour can't be changed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Final Method\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A final method can't be overridden.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Interface\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All method definitions in an interface are abstract. Classes which implement the interface must override all methods defined in the interface.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A class may implement multiple interfaces.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Names of interfaces are usually nouns/noun phrases or adjectives/adjective phrases.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using interfaces to create class hierarchies makes very clean implementations but takes a lot of work to implement.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [missed a bit]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Enums\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Int Enums\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab flawed design pattern (design anti-pattern)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab can compare apples to oranges\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Java Enums\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public enum Colour \{\line
    RED, YELLOW, GREEN;\line
\}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab java will automatically create objects for these constants\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab get {\f1 toString()} conversions for free (converts to the name of the constant)\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab use UPPER_SNAKE_CASE as they're constants\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab get enumeration for free, and a method to return an array of possible values\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public enum Planet \{\line
    MARS(10.0), EARTH(5.0);\line
\line
    private Planet(final double mass) \{\line
        this.mass = mass;\line
    \}\line
\}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab here we use a constructor for the enumerated types\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab we can also define public instance methods which use this value\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab you can also override methods for each type:\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public enum Student \{\line
    EOIN(115600700) \{@Override public int getMark(int assignmentNumber) \{\line
        // implementation\line
    \}\};\line
\line
    public abstract int getMark(int assignmentNumber);\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab you can also have nested enums\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Generics\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab parameterise a class over one or more types\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab allows us to use the class for, e.g. a set of Integers or a set of Doubles\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab only have to define the class once, as a generic\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab creating arrays inside a generic class is non-trivial and we're not expected to know it\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Reference<T> \{\line
    private T reference;\line
\line
    public Reference(final T reference) \{\line
        this.reference = reference;\line
    \}\line
\line
    public T getReference() \{\line
        return this.reference;\line
    \}\line
\line
    public void setReference(final T reference) \{\line
        this.reference = reference;\line
    \}\line
\}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab can omit types if they can be inferred (diamond notation):\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 final Reference<Integer> reference = new Reference<>(1);}\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab could use a generic implementation by setting all types as {\f1 Object}, but then different types can go in the same class\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab also, when getting values, you'll need to cast whatever you get if you want to use it as another type\sa180\sa180\par}
}
