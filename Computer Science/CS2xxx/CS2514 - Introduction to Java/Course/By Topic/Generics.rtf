{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Generic Types\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab removing the need for runtime checks allows code to be made more efficient by the JVM\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If interested, get book \u8211- [Naftalin and Wadler, 2009].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Motivation for Generics\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab an example where we might not know the type is if we read in an array index from the user\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the code on the slide will compile and then generate a runtime error\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab want to tell the compiler "you can use the general implementation of the class, but there will only be objects of this type in the collection"\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ArrayList is a generic type\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Solution: Generic Types\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab You assign a value to the type when you want to use a generic class\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Can also write {\f1 G<>} if the type can be inferred\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Avoids code duplication because you can implement the class once and use it for many types\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 The Comparable Interfaces\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab shallow comparisons just compare object references\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab get true if the references are the same\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab deep comparisons compare attributes as well\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. two Integer objects might be deeply equal if they represent the same integer value\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Example\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab if we had subtracted the two values, we might get overflow, which would damage the result\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 A Simple Generic Class\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab a class can depend on multiple types, which are comma-separated in the angle brackets\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab by convention use single upper-case letters to represent these types\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab keeps class definitions short\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Using the Generic Class\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab can write {\f1 gi = new GenericClass<>(42);} due to type inference\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Wildcards with Extends\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab won't be examined\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Example\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 nums.add(3.14)} isn't allowed because {\f1 ? extends Number} guarantees that the objects in the ArrayList are all subclasses of Number, but doesn't tell us which subclass (they must all still be the same class)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab so we don't know which type we're allowed add\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab none of this is examinable\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 MyList\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab We implemented this as a recursive list class\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab code is available on moodle, lecture 13\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Let's try to turn it into a generic implementation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab replace {\f1 ints} with {\f1 Comparables}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab do something, then have no more than one recursive call \u8211- tail recursion\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab unchecked or unsafe operations is a serious warning\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab two objects may be of classes that implement Comparable but not be comparable to each other, e.g. an {\f1 Integer} and a {\f1 String}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab we need to turn our list implementation into a generic class\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Generic Linked Lists\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab T refers to the same class, so our list will always contain objects of the same class\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab we had to use comparable things because we made quicksort an instance method\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab if we use a class method for this, then our list can contain objects that aren't comparable, but the quicksort method can only be used when the objects are comparable\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Iterators\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An iterator is an instance of a class that implements the Iterable interface.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can use the extended for loop with these objects.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab overriding the remove method is optional (but you have to override the other two)\sa180\par}
}
