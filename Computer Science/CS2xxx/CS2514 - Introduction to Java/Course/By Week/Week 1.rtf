{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Info\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 24 lectures, 80%-20% split\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab CA will be test and lab assignments\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Test in the middle of the year (if at all)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Some lectures will use the blackboard\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab At these we have to take our own notes\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 All assignments have an official deadline and a grace deadline, you can submit until the grace deadline.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Content\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Class definitions\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Procedural and data abstraction\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Associations between objects\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Class hierarchies and inheritance\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Polymorphism and dynamic method binding\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Assignments will never tell you how to implement something \u8211-\u160?you're supposed to figure that out.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Book\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Head First Java by Kathy Sierra and Bert Bates. Second edition or newer.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Optional Extra Books\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Effective Java by Joshua Bloch (get it if you like programming)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Java Puzzlers by Joshua Bloch and someone else\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Head First OO Analysis and Design\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Design Patterns Elements of Reusable OO Software (very technical, get if you like OO design)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 What is Java?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A programming language\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A compiler (the javac compiler)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Compiles to java byte code\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A virtual machine\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Interprets java byte code\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You use the command {\f1 javac filename.java} in the command line to compile a java file. This will produce a file {\f1 filename.class}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Run the program by calling the {\f1 java} command on the main class (corresponds to the main function).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Example Java\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Song \{\line
  private String title;\line
  private String artist;\line
\line
  public String getTitle() \{\line
    return title;\line
  \}\line
\line
  public void playSong() \{\line
    // play song\line
  \}\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab comment lines with {\f1 //}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab have to declare whether methods and attributes are {\f1 public} or {\f1 private} (or maybe others, but we will only study those two)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab private classes are useful in some situations, but not at the top-level\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab have to write return type of methods\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab use {\f1 \{\}} to mark blocks\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 void} can only be used as a return type\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab don't forget semi-colons\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 {\f1 main()} in Java\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Main \{\line
public static void main(String[] args) \{\line
  // code goes here\line
\}\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 static} shows that it is a class method (rather than an instance method), which is needed for the main method\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Printing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 System.out.println("Hello");\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can also print to error:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 System.err.println("Hello");\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Creating New Objects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For a class "Dog":\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Dog john = new Dog();\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This creates a new {\f1 Dog} object and calls it "john". You need to have the first {\f1 Dog} because you're declaring the type of the object reference.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Dot notation used to access public attributes and methods:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 john.size = 2.0; john.bark();\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Objects in Java\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The java language doesn't specify how objects are implemented \u8211-\u160?that's up to each compiler.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An object reference is like a remote control that can control different objects \u8211- they have a type, and so can only control objects of one type. You can't do this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Cat remote = new Cat;\line
House remote = new House;\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But you can do this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Cat remote = new Cat();\line
Cat other = new Cat();\line
remote = other;\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Two exceptions:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 final} variables can only take 1 value, they can't be changed\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab When an object reference's type is {\f1 Object}, it can take any object reference\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Any object reference variable can be assigned the value {\f1 null}, which corresponds to nothing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 About {\f1 public}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here's a class with some mistakes:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Balance \{\line
    private int value = 1;\line
    private int numberOfTransactions = 0;\line
\line
    public void add(int increment) \{\line
      value = value + increment;\line
      numberOfTransactions = numberOfTransactions + 1;\line
    \}\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note that attributes (here {\f1 value} and {\f1 numberOfTransactions}) can be initialised in an explicit constructor or just in the class like this.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab An explicit constructor makes sure they're all in one place though.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The fix is this:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Balance \{\line
    private static final int INITIAL_VALUE = 2;\line
    private int value = INITIAL_VALUE;\line
    private int numberOfTransactions = 0;\line
\line
    public void add(int increment) \{\line
      value = value + increment;\line
      numberOfTransactions = numberOfTransactions + 1;\line
    \}  \line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This way, if the initial value of the first int needs to be changed later, it'll only have to be changed in one place.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Note Class\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1         /**\line
         * one-line description\line
         * @author\line
         */\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This above is a javadoc comment. The first line should be a one-line description of the class. Since we're making a note class, that description might be, "A class to represent a short Note."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For our assignments, we need to write this, and we should put our name and probably student number in the author section.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 These should be at the top of the class, and before public members.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Note \{\line
    private static int MAX_LENGTH = 40;\line
    private final String comment;\line
\line
    private Note(final String comment) \{\line
        this.comment = comment;\line
    \}\line
\line
    public static Note createNote(final String comment) \{\line
        final Note result;\line
        if (comment.length() > MAX_LENGTH) \{\line
            result = null;\line
        \} else \{\line
            result = new Note(comment);\line
        \}\line
        return result;\line
    \}\line
\line
    public void print() \{\line
        System.out.print(comment);\line
    \}\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Normal comment blocks start with {\f1 /*} and end with {\f1 */}. You can also comment a single line with {\f1 //}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Class names should be nouns, always written uppercase.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Use spaces for indentation and not tabs.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We want to guarantee that notes have to be short, have to be under a certain length.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For this we need a maximum value. Rather than make this an instance variable, which will copy it for every instance, we're going to make it a class attribute, so all classes will point to the one value.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab We use the identifier {\f1 static} to make class attributes.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Names can contain letters and underscores, and other symbols.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab We're to use the convention that class attributes are written in all-caps.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Our names should start with letters.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Names should be meaningful \u8211- one-letter names are not meaningful.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We use {\f1 final} for the comment itself, purely by choice (we don't want the comments in this class to be changeable).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 comment} is an instance variable, as each instance needs to have its own note.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We're using a private constructor. We're gonna provide an API for clients, and that way we can easily change the details of our constructor and no-one will be harmed.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We use {\f1 final} in the constructor to prevent people from making an assignment in the method call, which can be done in Java but is probably a mistake.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note that assignment is not equality.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We're providing a class method for the service of creating a new note. If it was an instance method, we'd have a chicken-and-egg problem, as we'd need to have a note before we could use the method.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Reminder that formal parameters are the ones written in class definitions. Actual parameters are the ones passed to a method from the outside.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If given an invalid comment, we're going to return a null reference, and otherwise we'll return the new note.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Much clearer to have only one return statement at the end of a function, rather than having more than one.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab We'll use a result variable, and we make it final as a safeguard.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Lines should not exceed about 76 characters, short lines should be used instead.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab line continuations should be indented on the next line\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The braces are not needed for if or else blocks if there's only one statement in the block, but it's clearer to use them even then.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We could implement the method for printing a note as a class method, but then we'd have to pass the note as an argument. It makes more sense as an instance method.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We use {\f1 System.out.print()} rather than {\f1 System.out.println()}, as {\f1 println} adds a newline at the end, which we don't want.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab In this we could have used {\f1 this.} to be clear, but we don't need it now, because the name doesn't conflict with a formal parameter name.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab We usually use {\f1 System.err} instead of {\f1 System.out} to record error rather than print to the user.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab The output and error can be redirected e.g. in bash:\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab {\f1 java Note > output 2> errors}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab note {\f1 >} is shorthand for {\f1 1>}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab This allows you to automate your testing, e.g. using {\f1 cmp}.\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab {\f1 If cmp output correct_output; then    #    else    ...    fi}\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab It is possible to program in Java entirely using class methods, but then you must always pass the objects to the methods.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. {\f1 public static void print(final Note note) \{\}}\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Call By Value Mechanism\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There is often a question about this on the exam.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In Java, method calls use a call by value mechanism.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can think about this as each method call making a copy of the actual parameters and using those copies for the formal parameters in the method.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here's how you can think of the process:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For each formal/actual parameter\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab create a fresh variable\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab usually stored on the stack at runtime\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab this mechanism is also used for blocks\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab From left to right evaluate and assign the actual parameters\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Carry out the statements in the body of the method\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If there's a return value, substitute it for the method call\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Upon return remove the temporary variables\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Example\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public static int fib(final int n)\{\line
    if (n <= 1) \{\line
        return n;\line
    \} else \{\line
        final int result = fib(n-1) + fib(n-2);\line
        return result;\line
    \}\line
\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We can simulate a call to this method for an actual parameter of 2:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab put the actual parameter (in this case 2) on the stack, call it n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab now n is not <= 1, so we enter the else clause\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab temporary variable {\f1 result} is created and put on the stack\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab we now need to evaluate the two calls to fib to figure out the value to give {\f1 result}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the new actual parameter (1) is put on the stack and labelled n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab this time n is <= 1, so we return n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab this value (1) is substituted for the first internal call to {\f1 fib}, and n is removed from the stack\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the next actual parameter (0) is put on the stack and labelled n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab again n is <= 1, so we return n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 0 is substituted for the second internal call to {\f1 fib}, and removed from the stack\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab result is evaluated (1), and returned\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the stack is cleared\sa180\par}
}
