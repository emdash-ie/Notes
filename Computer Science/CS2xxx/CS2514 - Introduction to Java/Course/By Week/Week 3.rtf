{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Partially Filled Arrays\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You must fill the array before you can use it. You usually start filling at the bottom (index 0). Then fill the next position and so on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 final Scanner scanner = new Scanner(System.in);\line
final int[] values = new int[scanner.nextInnt()];\line
\line
int size = 0;\line
int next = 0;\line
while ((size != values.length) && (next >= 0)) \{\line
    System.err.println("Next value (negative value to stop): ");\line
    next = scanner.nextInt();\line
    if (next >= 0) \{\line
        values[size++] = next;\line
    \}\line
\}\line
\line
final double percentage = 100.0 * size / values.length);\line
System.out.println("Percentage filled is " + percentage);\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We use {\f1 System.err} for the user prompts so that we can suppress that if desired and still get the output message.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Say we're testing with a stream of numbers and we don't need to be instructed about them, but we still want to see the result.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab No negative indices for arrays.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Don't forget to initialise arrays. Operations on {\f1 null} cause runtime errors.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Parallel Array Implementation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class AccountManager \{\line
    private final String[] owners;\line
    private final double[] balances;\line
\line
    public AccountManager(final int size) \{\line
        final Scanner scanner = new Scanner(System.in);\line
        owners = new String[size];\line
        balances = new double[size];\line
        for (int index = 0; index != size; index++) \{\line
            owners[index] = scanner.next();\line
            balances[index] = scanner.nextDouble();\line
        \}\line
    \}\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Class-Based Implementation\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Create an {\f1 Account} object to store in the array, which will hold the owner and the balance each time.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Comparison\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The parallel array implementation is not safe:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Parallel array clients need access to all arrays:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 withdraw(owners, balances, nr, amount);}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This gives the client access to all account details\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab They can modify the array.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This violates encapsulation.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Direct access for Account clients:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\f1 account.withdraw(amount)}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Much safer.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Designing Classes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Methods are good because:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab They provide reusable computations\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab They're building blocks of complex computations\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Calls are the only mechanism to change private variables.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Pass-by-Value Mechanism\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Makes copies of the actual parameters.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Create a fresh variable for each parameter\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab For i from 1 to n:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 1.\tx360\tab Evaluate the ith actual parameter\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 2.\tx360\tab Assign the result [\u8230?][\u8230?]\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab When putting automatic variables on the stack, the order they go in depends on the JVM.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab In exams you can write them in any order, but make sure you label them correctly.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Class Design\par}
{\pard \ql \f0 \sa180 \li0 \fi0 How do we choose the classes, attributes, and methods?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note: problem specifications for assignments will sometimes be incomplete\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Look for actors in the specification. These actors do things and own things. The things they do are methods and things they own are attributes. Typically you're looking for nouns that are the subject/object (I forget which is which) in a sentence.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Toy Class\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Toy \{\line
    private final String name;\line
    private boolean used;\line
\line
    public Toy(String name) \{\line
        this.name = name;\line
        used = false;\line
    \}\line
\line
    // Getter and setter methods omitted.\line
\line
    @Override\line
    public String toString() \{\line
        return "Toy[name = " + name + "]";\line
    \}\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Hand Class\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public class Hand\{\line
    private final String type;\line
    private Toy toy;\line
\line
    public Hand(String type) \{\line
        this.type = type;\line
        toy = null;\line
    \}\line
\line
    public void take(final Toy toy) \{\line
        // We cannot take a Toy if the Hand is full\line
        if (isFull()) \{\line
            // output error\line
        \} else if (toy.getUsed())\{\line
            // We cannot take a used Toy\line
\line
        \} else \{\line
            // Take to.\line
            // Formally mark toy as used\line
            toy.setUsed(true);\line
        \}\line
\line
\line
    \}\line
    public void drop() \{\line
        if (isEmpty()) \{\line
            // We can only drop a toy if we have one\line
            // Error message\line
        \} else \{\line
            //Drop our current toy\line
            // Formally mark toy as free\line
            toy.setUsed(false);\line
            toy = null; // check this\line
        \}\line
    \}\line
\line
    public String getType() \{\line
        return type;\line
    \}\line
    public boolean isEmpty() \{\line
        return toy == null;\line
    \}\line
    public boolean isFull() \{\line
        return !isEmpty();\line
    \}\line
    [\u8230?]\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab top-down approach means using methods in others before we write them, in order to figure out that we need to write them\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Using strings for marking "left" and "right" is not ideal, because the compiler can't help you if another string is passed.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Another solution (still not ideal) is to introduce class constants defined to allowed values, but there are still problems.\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab These {\f1 LEFT} and {\f1 RIGHT} constants should be moved to the Hand class.\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab A better way is to define an object class that only has the two acceptable values, this way you can use the type to guarantee that only allowed values are passed.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Designing Classes (cont.)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 for} and {\f1 while} loops\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 invariants} - comments about object relationships\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab linear search algorithm\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab proof of correctness with {\f1 invariants}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab top-down approach:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab start with a description in English, revise the implementation step by step until you end up with Java\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 {\f1 for} loop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 for ([initialisation]; [condition]; [update]) \{\line
    [stuff]\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The initialisation is called first\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the condition is checked at the start of each loop\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The update is carried out at the end of every iteration\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab be careful of 1s and ls looking similar\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab you should minimise the scope of variables to ensure that it only covers the loops\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab do this by declaring your counters in the initialisation section of the loop\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab this variable will only exist for the lifetime of the loop\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 // do this:\line
for (int digit = 0; digit <= 1; digit++)\{\line
\line
\}\line
//not [insert]:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 {\f1 while} loop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 while ([condition]) \{\line
    [stuff]\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab you don't need braces if there's only one command in the loop, but you should use them to make things clearer\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 {\f1 do while}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 do \{\line
    [statement]\line
\} while ([condition]);\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This will execute the statement before checking the condition, instead of checking first and doing the statement after, each time.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab It's equivalent to putting the statement in one extra time before a {\f1 while} loop.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Invariants\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Invariants relate the values of the variables in your program.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab They make the relationships explicit (a form of documentation)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab They may help you prove the program is correct\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab They help you maintain your program\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Easier to remember what your code is meant to do\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You should state invariants as comments in your programs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 if ([condition]) \{\line
    // [condition]\line
\} else \{\line
    // ![condition]\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab listing the condition in the comment helps make it clearer\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab also with the {\f1 else}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 // [condition1]\line
while ([condition2]) \{\line
    \u8230?\line
    // [condition1]\line
\}\line
    // ! [condition2]\line
    // [condition1] && ![condition2]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 in i, sum;\line
\line
i = 0;\line
sum = 0; // i <= 100 && sum == ) + 1 + \u8230? + i\line
while (i < 100) \{\line
    i = i + 1;\line
    sum = sum + i; // i <= 100 && sum == 0 + 1 + \u8230? + i\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Linear Search\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 int index = 0;\line
\line
while (index < array.length && !satisfies(array[index])) \{\line
    index++;\line
\}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab We can put our search condition in the while condition like this\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab You can prove that it's correct with invariants\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Not sure which ones we should put in here.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Battleship\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Simplified version:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Only have one "dotCom"\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Represent it as a 3-value int array\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Values are location cell numbers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Location cells are consecutive numbers between 1 and 7\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab User guesses location cells\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If the user guesses right we announce a hit\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If there are three hits [\u8230?]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Steps:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Figure out what the class is supposed to do\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab List the instance variables and methods\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Write prep code for the methods\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Write test code for the methods\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab helps clarify what the methods needs to do\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab helps design the method API\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab test code acts as documentation/contract\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab by writing test code early, we can use it early and eliminate bugs\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 5.\tx360\tab write real code for the methods - write the class\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 6.\tx360\tab debug and implement as required\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note that these steps were developed before JUnit testing, which can be done instead of writing the test code.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Read the book to find out how to write test code\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Code\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 public String checkYourself([\u8230?]) \{\line
    final int cell = Integer.parseInt(guess);\line
    final boolean found = findLocation(cell);\line
\line
    hits += (found ? 1 : 0);\line
    // ternary operator - if found is true, the expression becomes 1\line
    //      if found is false, the expression becomes 0\line
    // So this increments hits if found is true\line
\line
    return getResultAsString(found);\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Need an instance variable that generates a random number. This comes from the random class:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Random()\line
// There are a few constructors\line
Random(seed)\line
// seed must be a `long` value\line
// allows you to reproduce the same sequence of random numbers, e.g. for testing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 rand.nextInt(maxStartValue);\line
// this gives a random value up to but not including maxStartValue,\line
// assuming you've created the variable `rand` already\par}
}
