{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Joins (cont.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using joins to find the name of all employees working in the same department as Joyce English:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT RE.Fname, RE.Lname\line
FROM EMPLOYEE LE, EMPLOYEE RE\line
WHERE LE.Dno = RE.Dno\line
    AND LE.Ssn != RE.Ssn\line
    AND LE.Fname = 'Joyce'\line
    AND LE.Lname = 'English';\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Find the name of employees working in the same department as Joyce English who earn more than her:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT RE.Fname, RE.Lname\line
FROM EMPLOYEE LE, EMPLOYEE RE\line
WHERE LE.Dno = RE.Dno\line
    AND LE.Ssn != RE.Ssn\line
    AND LE.Fname = 'Joyce'\line
    AND LE.Lname = 'English'\line
    AND LE.Salary < RE.Salary;\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note that now the Ssn condition is unnecessary, because one row can't have two salary values, so the salary condition excludes all rows with the same person on each side.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Left Outer Join\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Any normally unmatched row from the left table will automatically match a null row appended to the right.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g. find the name of every Texas-based employee, together with the name & relationship of any dependents they might have:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT Fname, Lname, Dependent_Name, Relationship\line
FROM EMPLOYEE LEFT JOIN DEPENDENT\line
WHERE Ssn = Essn\line
    AND Address LIKE '%TX';\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For most implementations besides MySQL, you can use the following notation instead of {\f1 LEFT JOIN}:\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT [\u8230?]\line
FROM EMPLOYEE, DEPENDENT+\line
WHERE [\u8230?]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Synchronised Subqueries\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also called:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Correlated subqueries\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Subequeries with interblock reference\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The inner block refers to a column in its parent block. (You can only refer up one level.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 They evaluate more like joins than subqueries.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 MySQL syntax:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT Fname, Lname\line
FROM EMPLOYEE E\line
WHERE 'Research' IN\line
    (SELECT Dname\line
     FROM DEPARTMENT\line
     WHERE Dnumber = E.Dno)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab For other implementations, you don't need to use an alias with employee.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab You can just write {\f1 \u8230?WHERE Dnumber = Dno}.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note using {\f1 =} instead of {\f1 IN} will work because you can be sure that you won't get two results from the subquery\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The order of evaluation is changed. The query evaluates top-down:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Look at the first row of the {\f1 EMPLOYEE} table.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 1.\tx360\tab Evaluate the interblock reference\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 2.\tx360\tab Evaluate the subquery\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 3.\tx360\tab Include or don't include the row\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Look at the second row of the {\f1 EMPLOYEE} table.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 1.\tx360\tab Evaluate the interblock reference\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 2.\tx360\tab Evaluate the subquery\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 3.\tx360\tab Include or don't include the row [\u8230?]\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The subquery is run once for each row, which is potentially very inefficient.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Regular subqueries are much more efficient, and joins are probably more efficient as well.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here're examples where you might have to use synchronised subqueries:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Find the name and id of all departments employing people from Houston:\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT Dnumber, Dname\line
FROM DEPARTMENT D\line
WHERE EXISTS\line
    (SELECT *\line
     FROM EMPLOYEE\line
     WHERE Address LIKE '%Houston%'\line
         AND Dno = D.Dnumber);\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Find the name and id of all departments employing no-one from Houston:\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SELECT Dnumber, Dname\line
FROM DEPARTMENT D\line
WHERE NOT EXISTS\line
    (SELECT *\line
     FROM EMPLOYEE\line
     WHERE Address LIKE '%Houston%'\line
         AND Dno = D.Dnumber);\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Inserting Data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 By default new rows are entered at the bottom of the table.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab In general you can only add data to one table at a time\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 INSERT INTO EMPLOYEE\line
VALUES ('Joan', 'J', 'McGregor', [\u8230?]);\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can populate tables from other tables:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 INSERT INTO HOUSTON_STAFF\line
SELECT Ssn, Dno, Salary\line
FROM EMPLOYEE\line
WHERE Address LIKE '%Houston%';\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Modifying Data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can only modify data in one table at a time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Address\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 UPDATE EMPLOYEE\line
SET Address = '18 Maple, Austin, TX',\line
    Salary = 50000\line
WHERE Ssn = '123457689';\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Give all employees of department 5 a 20% raise:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 UPDATE EMPLOYEE\line
SET Salary = Salary * 1.2\line
WHERE Dno = 5;\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can use subqueries (and joins, in MYSQL) to build the condition, but you can only ever update in one row.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Deleting Data\par}
{\pard \ql \f0 \sa180 \li0 \fi0 You can only delete data from one table at a time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 DELETE\line
FROM EMPLOYEE\line
WHERE Fname='Jennifer'\line
    AND Lname='Wallace';\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Verification\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When you get input to a table, you should verify the format and also any references to other tables (e.g. referencing a department that doesn't exist).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This prevents your table from getting very messy.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In practice, a lot of database administrators will restrict insert permissions to a small number of people, and will only allow insertion through a program that verifies the input.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The same things apply to deletion of rows.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Three options:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Do nothing (allow people to screw up the database)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Specify rules that the DBMS might apply to modification commands\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This slows down insertions, modifications, and deletes\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Perform data modification under program control\sa180\par}
}
