{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Application Layer\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We use the internet to do a lot of different things \u8211- the applications are different in terms of what they expect from the network underneath.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As we go through, think about how each application is different from the ones we've already seen in terms of how it interacts with the network. The further down the stack you go, the fewer protocols there are.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We will look at a lot of examples \u8211- we're aiming to learn the principles and concepts, not the particular details of any particular protocol.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Creating a Network App\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Write programs that\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab run on different end systems\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab communicate over the network\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab e.g. web server software communicates with browser software\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 No need to write software for network-core devices, means anyone can go and write an application that communicates with any protocol, and it'll work over the internet.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Having applications only on end systems allows for rapid app development and propagation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Internet Addressing\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Every computer on the internet gets a unique IP address:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This is assigned when it connects to the network\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Used to identify the destination when sending a packet\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Used by receivers to check who sent the packet (and to reply)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For convenience we often use hostnames, but these are mapped to a corresponding IP address when sending a packet.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab e.g. cs1.ucc.ie -> 143.239.75.218\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using hostnames is easier and less error-prone for people.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Application Architectures\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab client-server\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab including data centres / cloud computing\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. web server \u8211- expect it to always be available, whereas clients come and go\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab always-on host with permanent IP address\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab clients may have dynamic IP addresses\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab clients don't communicate directly with each other\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab peer-to-peer\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab bunch of clients get together and exchange info\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab no always-on server\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab peers are intermittently connected and change IPs\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab highly scalable but difficult to manage\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab hybrid of those\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. Skype\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab voice over IP P2P application\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab centralised server to find the address of a remote party (and tell what address you're currently at)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab client-client connection is direct, not through a server\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Instant messaging\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab similar to above\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Processes Communicating\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Within the same host, two processes communicate using inter-process communication, which is defined by the OS.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Processes in different hosts communicate by exchanging messages.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A client process initiates communications\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A server process waits to be contacted\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab applications with P2P architectures have client processes and server processes\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sockets\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A process sends/receives messages to/from its socket. A socket is an API.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab have to make choice of transport protocol\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab have the ability to fix a few parameters\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. allocate lots of buffer memory to me because I'm going to get a lot of messages\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Addressing Processes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Host device has unique 32-bit IP address (IPv4) \u8211- this is combined with a port number to give an identifier associated with a specific process on a host.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 App-layer Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This defines:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the types of messages exchanged\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. request/response\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab message syntax\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab what fields in the message are and how the fields are delineated\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab message semantics\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab meaning of the information in the fields\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab rules for when and how processes send and respond to messages\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Most protocols are public-domain protocols, mostly available on (IFC website?):\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab defined in RFCs\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab allow for interoperability\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab e.g. HTTP, SMTP, BitTorrent\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are also proprietary protocols:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab e.g. Skype, ppstream\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 What Transport Service Does an Application Need?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Different apps expect different things:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab data loss\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab some apps (e.g. audio, voice, games) can tolerate some loss\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab most apps (e.g. file transfer, email) require 100% reliable data transfer\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab timing\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab some apps (e.g. internet telephony, interactive games) require low delay to be effective\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab throughput\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab some apps (e.g. multimedia) require minimum amount of throughput to be effective\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab most apps (elastic apps) make use of whatever throughput they get\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab e.g. downloading files happens at whatever speed is available\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab security\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab does an app need encryption, authentication\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Popular Internet Transport Protocols\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Only two are widely used, though many others exist. TCP is dominant (about 98% of traffic), though UDP is likely to grow going forward.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TCP (Transmission Control Protocol)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab very complex\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab provides reliability end-to-end\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab uses sequence numbers to detect lost or out-of-order packets\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab these are retransmitted (extra delay)\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab additional features to control the sending rate so as to match the available network and receiver buffer capacity\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab features to try to avoid congestion on the network\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab doesn't provide:\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab timing guarantees\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab minimum throughput guarantees\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab security\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab UDP (Unreliable Datagram Protocol)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab much simpler than TCP\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab very basic delivery service that offers no guarantees about delivery between sending and receiving processes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab does not provide:\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab timing guarantees\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab rate control\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab minimum throughput guarantees\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab security\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab very common for UDP to be disabled because it has features that network admins hate\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab firewalls usually block it\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Programs like Skype try to use UDP if it's available, but revert to TCP if it isn't\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Question to think about: why use UDP?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Applications\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Concentrate on the differences and commonalities between all of these applications.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Web and HTTP\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Some jargon first:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab web page consists of objects\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab objects can be html files, jpeg images, java applets, audio files\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab base html file which includes several referenced objects\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab each object is addressable by a URL\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 HTTP\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Doesn't matter what the clients are running (OS, programs) as long as they generate requests in the right format (http).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Always uses TCP.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab mostly because it needs reliability\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 TCP Basics\par}
{\pard \ql \f0 \sa180 \li0 \fi0 TCP requires the sender and receiver to set up a connection.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab before any user data is transferred\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab has to be closed again when finished\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This incurs delays (round-trip time delays - RTT). These delays are both for open and closing connections, and both of those areas are important.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When designing applications, we need to think about how the performance of the transport layer affects the performance of our applications.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It is dangerous to design applications without knowing about the performance characteristics of lower layers. Don't choose TCP without knowing about its efficiency.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 HTTP\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The client initiates a TCP connection (creates a socket) to the server on port 80\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The server accepts TCP connection from the client\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab HTTP messages (application-;ayer protocol messages) exchanged between browser and web server\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab TCP connection closed\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Stateless Protocol\par}
{\pard \ql \f0 \sa180 \li0 \fi0 At the protocol level (i.e. not cookies) http is stateless. This makes the protocol simpler.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 State makes protocols very complex:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab past history (state) must be maintained\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab if server/client crashes, their views of state may be inconsistent, must be reconciled\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Non-Persistent HTTP\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Because we choose TCP (because we need reliability), we incur performance overheads for setting up the connection. This leads to some strange behaviour.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If we want to load a page with several images, the setup and closing of the TCP connection is repeated for each image, even if the images are on the same host. So we incur a lot of delay.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First optimisation:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Send off image TCP requests in parallel instead of in series\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Normally there's a limit of about 10 parallel TCP connections per server. Lots looks like a DOS attack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Persistent HTTP\par}
{\pard \ql \f0 \sa180 \li0 \fi0 HTTP 1.1 introduced persistent HTTP, where multiple objects can be sent over a single TCP connection between a client and a server. It's used when there's a bunch of objects on one server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Raises the question of when to close the connection.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Pipelining\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next optimisation:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Send requests in parallel\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This isn't very widely used, and there'll be an explanation later.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 HTTP Messages\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab In ASCII (human-readable)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Binary formats are much more efficient (each ASCII character takes a byte)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab But binary formats are a pain to deal with\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab You can easily view and debug ASCII protocols\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Binary-based protocols tend to be preferred where link efficiency is important, otherwise ASCII\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 HTTP Requests\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 HEAD} is sometimes useful to e.g. check the size of a file or when it was last modified, without downloading it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Cookies\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Part of the application but kept in the header for the http protocol.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab State information, but not protocol-level information\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Doesn't tie together multiple http sessions\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cookies permit sites to learn a lot about you\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab You may supply name and email to sites\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab They can learn a lot about you as a real person\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Web Caching\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab All requests go through a proxy server\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Proxy stores webpages requested\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Can then deliver the cached version instead of sending a request for the original again\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This decreases load on the origin server and reduces latency for cached pages\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Have to empty the cache as it fills\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Caching provides great reduction in congestion, but won't work for https traffic (each page is encrypted so it can only be viewed by whoever requested it).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also, what about websites which change? How do you know whether a website has changed and you therefore need to get the newest version.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To get around the latter:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Send a conditional GET \u8211- only get it if it was modified since the attached date and time.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab If it hasn't been modified, then an error is sent back\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab In this case use the cache version\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are other problems:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The cache can't provide customised experience because it doesn't understand your cookie\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Personalised advertising is ruined\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Content providers don't get any detailed information about how you're using their page\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab e.g. it's too slow\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Content providers can put a "do not cache" line in the header, and most do this for a lot of their content.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 HTTP/2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Main goal is to reduce page load times:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab binary encoding and header compression\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab binary rather than ASCII\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab server can "push" content that it believes the client will need, e.g. interdependent objects\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab potentially huge benefits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab might send you stuff you don't want, which might cost you a lot or be annoying\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Eliminates head-of-the-line blocking from HTTP/1.1 for pipelining by allowing asynchronous request/response\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab answers had to came in order in HTTP/1.1 \u8211-\u160?server could work in parallel, but couldn't send later responses before earlier ones\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab now they can be sent asynchronously\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab concept of multiplexing prioritised "streams" of requests/responses over a HTTP/2 session\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 FTP\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One of the oldest protocols on the internet.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Opens two TCP connections:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab one for control (I want this file, etc.)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab this is a persistent connection, which stays for the length of the conversation\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab a different connection for each transfer\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab these are non-persistent (closed after the file is transferred)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab can disable this if you want to use one TCP link to send multiple files\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Control connection is ASCII.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Separates control and data.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Email\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Three major components:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab user agents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab mail servers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab acts as both client and server\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab has to send email to other servers\sa180\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab simple mail transfer protocol (SMTP)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab uses TCP because it needs reliability\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 SMTP\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Emails are transferred directly between servers. Unlike the postal service, there are no intermediaries \u8211- establishes a direct connection to the destination server and sends it.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab By default all messages are assumed to be 7-bit ASCII\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab This is extended by MIME\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab allows e.g. attachments\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There's handshaking protocols, including checking if the server you're contacting has the particular user.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Uses persistent connections\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Is a push protocol, unlike HTML\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab "I've got an email to push to you"\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Multiple objects sent in multipart message\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Mail Access Protocols\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For retrieval of emails by client from server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [\u8230?] * IMAP * more features * assumes you keep messages on server * HTTP * gmail, hotmail, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 POP3\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ASCII\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab pull-based\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 DNS (Domain-Name System)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Unlike the others, this is crucial to the operation of the internet.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Without it you could only visit sites whose IPs you already know.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Host names are much easier to remember and communicate to people than IP addresses.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 DNS is a distributed database implemented in the hierarchy of many name servers.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It's an application-layer protocol:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab hosts, routers, name servers communicate to resolve names\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It's a core internet function, but it's implemented at the edge of the network, which makes it easier to change.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Services\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Aliasing\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab canonical, alias names\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab mail server aliasing\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab which gmail.com computer handles email?\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab load distribution\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab replicated web servers\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab set of IP addresses for one canonical name\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab e.g. redirect different people to different machines that have the same content\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 DNS is not centralised to avoid having a single point of failure, or having excess traffic volume to a single server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Distributed, Hierarchical Database\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Root DNS Servers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Top-level domain servers (e.g. .com, .org)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab servers for different organisations, e.g. amazon, yahoo\par}
{\pard \ql \f0 \sa0 \li1440 \fi-360 \endash \tx360\tab may have more below this, e.g. for different departments\sa180\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Imagine that it works like this:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab client queries root server for amazon.com, which tells the client where the .com server is\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab queries .com for amazon, tells the client where amazon is\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab queries amazon, which tells the client which machine to contact\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are 13 root name servers worldwide.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 TLD and Authoritative Servers\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Usually run by companies (e.g. Network Solutions for .com).\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Authoritative Servers are the ones for each organisation, which are an authoritative source\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Local Name Server\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Each ISP has one \u8211-\u160?also called default name server. Typically you contact these, and they contact the higher-up servers if needed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Name Resolution\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Iterative version and recursive version.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Caching\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Caching done at every level. Stored values timeout to lessen cache inconsistency.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Root name servers not often visited.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Very unlikely that you have to worry about a cache filling up, because they're only storing small values.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Argument for using a timeout rather than checking with the origin server is that cache consistency is not very serious.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 DNS Records\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Known as resource records\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Four fields:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab name\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab value\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab type\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ttl\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Type = A\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\f1 name} is hostname * {\f1 value} is IP address\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Type = NS\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 name} is domain\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 value} is hostname of authoritative name server for this domain\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Type = CNAME\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 name} is alias name for some canonical name\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 value} is canonical name\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Type = MX\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 value} is name of mailserver associated with {\f1 name}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Types CNAME and MX allow you to have many servers accessible at the same url.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 DNS (cont.)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab important to remember that you can take DNS out and the lower layers all still work totally fine\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab local computer only ever talks to your local nameserver, which talks to all the other nameservers on your behalf\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab recursive resolution requires keeping state on all intermediate servers\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab this gets messy, and so is less used\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Caching\par}
{\pard \ql \f0 \sa180 \li0 \fi0 If DNS didn't have caching, it wouldn't scale as well as it does (the root servers would always be too busy).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Inserting Records into DNS\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab different TLDs have different requirements and different costs\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab .ie is more strict (you have to prove you're a representative of a real company or etc.) and so better-managed\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab may want the flexibility of moving webserver from one computer to another\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab so use an alias for the main address (www.networkutopia.com maps to 2141nj.networkutopia.com)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab only have to change 1 DNS address (the alias)\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 File Distribution\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Could just use FTP, but this is bad:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Response time gets very high for large numbers of users or files\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Mirror Sites\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab user is the one who selects a mirror\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Issues\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab need fast copying between mirrors to ensure consistency of files\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab need to think about how to guide users to spread load across mirrors\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Content Distribution Networks (CDNs)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab created to address issues with mirrors\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab essentially automated mirrors\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab user is directed to a mirror by the CDN (rather than picking one themselves)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 CDNs have large servers distributed globally.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab CDNs often place servers at the edge of the backbone network (e.g. Netflix in .ie)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab need to be able to react very quickly to e.g. a new very popular video on youtube\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab a lot of deciding how many replicas and where is to do with AI and machine learning\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Overlay Network\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab CDN visualises its own network sitting on top of the internet\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab avoids large amounts of same data repeatedly travelling large sections of the internet\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab reduces congestion\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab improves latency\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab reduces server load\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab redirection can be done with DNS or HTML\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Partial Site Delivery\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab origin server can now see all users that request content from it\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab same as caching downsides\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 CDN vs. Caches\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab something only goes in a cache if it's been requested (reactive)\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab CDNs are proactive\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab caches give low access time as a side effect \u8211- actually more concerned about reducing network traffic\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note: there are agreements (SLAs) between CDN providers and content providers about guaranteed latency, provision of measurements, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 P2P\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab changes over time \u8211- different peers online at different times\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab you can distribute files much more effectively than client-server, but how do you search for the info you're looking for? Who has it?\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab highly scalable and good performance, but difficult to manage\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab client-server is linear in download speed for large numbers of clients\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab p2p is logarithmic\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 BitTorrent\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab uses TCP for reliability\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab pull-based\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab you tell peers you want it, they don't know otherwise\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab designed in a way that encourages you to share the pieces you have with other users\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab torrent definition\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab group of peers exchanging pieces of a file\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab tracker normally gives you a subset of the entire number of users\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab tracker is specified in the torrent descriptor file\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab while downloading, peers must upload pieces to other peers\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab once finished, you can leave or stay\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab BitTorrent is reputation-based \u8211- if you often seed, you will get better connections (though it won't go far above your connection speed because that would be a waste)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab neighbours are the set of users you're connected to on the overlay network\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab need to randomly select a peer every now and then and send files to them in order to allow new users to join the network\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab other than that it's by how much they're sending you\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab high upload rate important to P2P\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Distributed Tracking\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 DHT\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab want spread evenly because otherwise many lookups going to one node\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 Circular DHT\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Skype\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Streaming\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab mostly video\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab makes for the majority of network traffic\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Client-side Buffering, Playout\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 File Distribution (cont.)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Streaming Stored Video (cont.)\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab most info applies to streaming audio as well\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab client-side buffer acts as a cushion\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Client-side Buffering\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab buffer starvation is when the buffer is empty\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab the bigger the buffer, the bigger the initial playout delay\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab user experiences large delay before the video plays\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab if the user decides at the beginning they don't want it, there's a lot of data wasted\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab a big problem if the user is charged by the amount of data\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Streaming Multimedia: HTTP\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab used for most video streaming today\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab this is new\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab in the past it would've always been expected to be UDP because video tolerates loss\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab we use http because it's common and gets through firewalls\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 DASH\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab this is an MPEG standard\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab most widely-used\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Netflix and Youtube use proprietary standards that have been reverse-engineered and seem very similar to DASH\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab 4s pretty typical for a chunk\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab GET request for each chunk\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab what algorithm should the client use for deciding when to fetch each chunk?\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab this isn't specified in the standard\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Netflix has about 100 different quality levels per chunk\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab In practice, most clients pick the best server at the beginning, but don't make that decision again later\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab distributed DASH is new and is likely to change this\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Case-study: Netflix\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Since 2014, Netflix have made their own CDN, use that rather than those mentioned on the slides\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab the older system allowed them to get set up very quickly, without having to put the infrastructure in place first\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab diagram is probably correct rather than the preceding slide\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab registration and accounting kept on Netlix's own servers\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Summary\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab in-band and out-of-band control\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab separate channels for control messages is out-of-band, example is FTP\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab HTTP is in-band\sa180\sa180\par}
}
