{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Info\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This course will take what we did in CS2515 and expand on it: * Bigger data structures * Harder problems\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab All programming examples and assignments will use Python 3.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 80% final exam, 20% CA and in-class tests\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Labs Tuesday morning, 09:00\u8211-11:00\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab It's assumed you're spending at least 8 hours per week per 5 credit module.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Book\par}
{\pard \ql \f0 \sa180 \li0 \fi0 No required textbook. Recommended textbooks:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 [get from notes]\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Overview\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Revision of CS2515\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Complexity and analysis\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Will formalise complexity more than last term\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab Sorting and selecting\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Graphs\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab e.g. maps or social networks\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 5.\tx360\tab Sample algorithms in text processing, matching, and memory management\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Revision of CS2515\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Almost everything in Python is an object, stored in some location in memory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There are 2 underlying ways of implementing data structures:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Array-based\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Linked structures\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Array Implementations\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An array is a sequence of items all of the same type, laid out one after another in a fixed-size chunk of memory (i.e. a sequence of bits). Because we know the size of each item, we can compute the location of any item in the array and jump straight to it in constant time.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 But, if we want to add items beyond the fixed size, we have to create a new array of the right size and copy the data across.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Linked Structure Implementations\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A node is an object containing references to an item and to other nodes.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A collection of nodes referring to each other creates a data structure, but where each node can be placed anywhere in memory.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab To access a particular item, we need to iterate through a chain of references.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab There's no limit on the size (apart from the total memory in the system).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Main Linked Structures in CS2515\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Linked list \u8211- a linear sequence\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If we are given a location it's easy to update, but it's slow to search\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Binary search tree\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Reasonably fast to update and fast to search (assuming the tree is balanced)\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab AVL tree \u8211- a balanced binary tree\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Reasonably fast to update and fast to search because it's always balanced\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Two Types of Tree in CS2515\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Binary search tree \u8211- use it for search\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab for each node, all left descendants are lesser, and all right descendants are greater\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Binary heap \u8211- use it for priority queues\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab for each node, all descendants have lower priority (and the tree is full, except possibly for the lowest level, which is full from left up to a point and then empty)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the most efficient implementation uses an array-based list, not a linked tree\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Maps and Hashing in CS2515\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Used an array-based list, possibly with other lists in each cell.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Maps are good for fast lookup and storage\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The key for a value helps tell you where it will be stored.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Almost always fast lookups by controlling the size of the underlying array, but occasionally can be slow (long chains, large buckets, etc.)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 CS2515 Exam\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Most of the exam was bookwork.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab There were 3 questions\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Question 1 on linked lists and stacks\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Question 2 on binary heaps\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Question 3 on maps and hashing\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab In general question 1 was done best.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Main Issues\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Final part of Q1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This was the MinStack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The best solution is to use two stacks, where the value in the second stack is the minimum value at the time of the corresponding value in the first stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g. if you push a value that's not smaller than the top of the second stack, you push the value on the top of the second stack onto it again. When popping from the main stack, you also pop from the second stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When doing these unseen questions, make sure that your solution works.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Many people used a variable to track the min, and never explained that you then need to search the stack if you pop the min.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Question 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Question 2 was about binary heaps rather than binary search trees \u8211- some people answered only on binary search trees.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Either people didn't read the question carefully enough, or didn't cover it when revising.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Question 3\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This was all bookwork, but from the last couple of lectures.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This wasn't done as well as question 1.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Either people didn't understand it, or didn't cover it when revising.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Recursion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Activation Records\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When Python executes a function, it creates an activation record which stores:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab variables passed in as parameters\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab local variables created inside the function\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the point in the function source code it has reached\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It pushes this onto a stack of activation records.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 When it finishes executing the function, it:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab pops the record off the stack and deletes it, remembering any return value\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab moves to the record now on top of the stack, and returns to the point in the source code it had reached, and passes in the return value\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Note global variables are stored somewhere other than this stack, and can be accessed at any point.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab If you want to use a value returned from a function, every path through the code must reach a return statement in the function.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Otherwise the value will be deleted when the function is finished.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Recursive Programs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Every recursive function must have two things:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A base case\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This is a non-recursive code block that returns [check]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab A recursive call with parameters that bring you closer to the base case.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Memory\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With recursive functions on big data structures, you may end up with many activation records, taking up a large amount of memory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Unbounded Recursion\par}
{\pard \ql \f0 \sa180 \li0 \fi0 E.g. if you're not moving towards your base case in a recursive function.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Unbounded recursion uses a lot of memory very quickly, and behaviour is technically unspecified, as you may overwork the CPU.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Python avoids this by putting a limit on the call stack. It's normally set at something like 100 calls, but you can change this if you need to.\par}
}
