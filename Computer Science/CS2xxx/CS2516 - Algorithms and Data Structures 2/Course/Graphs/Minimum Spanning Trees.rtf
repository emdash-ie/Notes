{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Minimum Spanning Trees\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab spanning tree is a subgraph of G that is a tree and contains every vertex\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab minimum spanning tree is a spanning tree which has the lowest sum of weights of the selected edges\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Prim's Algorithm\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab repeatedly include the minimum-weight edge from a vertex that's in the tree to a new vertex\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Complexity\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Proof\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab for any algorithm you write, you should be able to prove that it does what you claim\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Kruskal's Algorithm\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Prim's algorithm worked by building a single tree one edge at a time until all vertices in the graph are in the tree.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There is another approach based on joining trees together until all vertices are in the graph.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab start by saying every vertex is its own tree\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab look for the cheapest edge that combines two trees\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab repeat\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 No proof yet, think about it before next week.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 \u160?Efficient Implementation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab use a priority queue for storing edges\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab efficient removal of minimum-cost edge\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab use a dictionary mapping vertices to the tree they're part of\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab represent each tree by a stack of vertices (or any sequence)\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab when joining trees:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab pop each element from the smaller tree\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab point the dictionary value for that element at the bigger tree\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab push the element into the bigger tree\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Complexity\par}
{\pard \ql \f0 \sa180 \li0 \fi0 O((n + m)logn)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab better tree merging gives better complexity\sa180\par}
}
