{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Directed Acyclic Graphs\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Directed Graphs\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab directed graph ADT same as undirected, but the order of the vertices in each edge is treated as significant\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab add a few methods to the graph as well\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Edge\line
    get_start()\line
    get_end()\line
\line
Graph\line
    in_degree(x)\line
    out_degree(x)\line
    get_in_edges(x)\line
    get_out_edges(x)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 in_degree} and {\f1 get_in_edges} look at edges pointing at x\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\f1 out_degree} and {\f1 get_out_edges} look at edges pointing away from x\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab a path is a sequence of vertices, such that each pair of adjacent vertices in the sequence is a directed edge in the graph\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab a cycle (in a directed graph) is a path of length >= 1 which starts and finishes at the same vertex\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Directed Acyclic Graphs\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab can draw any binary relation over a single set as a directed graph\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab an order relation's representation can't contain a cycle\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab a directed acyclic graph must have at least one vertex with in-degree = 0\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab proof: work backwards from any vertex over the in-edges\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab you'll reach a vertex of 0-degree or the graph contains a cycle\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Topological Sort\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Given a directed acyclic graph, a topological sort is an ordered sequence of all vertices in the graph such that if two vertices x and y in the graph have a directed edge (x, y), then x appears before y in the sequence.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab There can be multiple topological sorts for one DAG\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Algorithm\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab mark all vertices of in-degree 0 as available\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab for each vertex that's available\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab add to the end of your sort\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab decrement the in-degree of all vertices this vertex has an edge onto\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab mark any of those vertices available if they have an in-degree of 0\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 Code\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 def topological_sort(self):\line
    # assumed to be operating on a DAG\line
    in_edge_count = \{\} # map of (vertex:in_degree) pairs\line
    output = []       # list of vertices in sort order\line
    available = []   # vertices with no active in-edges\line
    for v in self._structure:\line
        in_count = self.in_degree(v)\line
        in_edge_count[v] = in_count\line
        if in_count == 0:\line
           available.append(v)\line
    while len(available) > 0:\line
        w = available.pop()\line
        output.append(w)\line
        for e in self.get_out_edges(w):\line
            u = e.opposite(w)\line
            in_edge_count[u] -= 1\line
            if in_edge_count[u] == 0:\line
                available.append(u)\line
    return output\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Exercises\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Write an algorithm which takes an arbitrary directed graph and returns True if it's a DAG, and False if it isn't.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 * do a breadth-first or depth-first search of the graph\line
\line
    * keep track of all vertices you've seen\line
\line
    * if you see one you've seen already, return False\line
\line
* if you get to the end of the graph return True\par}
{\pard \ql \f0 \sa180 \li0 \fi0 What is the complexity of the topological sort algorithm?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 * every vertex considered once in the for loop\line
\line
* every vertex considered once in the while loop\line
\line
* every outward edge from every vertex considered once in the inner for loop\line
\line
* O(2n + m) (= O(n+m)?), where n is the number of vertices and m is the number of edges\par}
}
