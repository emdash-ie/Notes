{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Adaptable Priority Queue\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Extend the priority queue to allow these with reasonable complexity:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab updating the key of an item\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab reading the current key of an item\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab removing an item\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Update PQ ADT by:\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab returning a reference to the Element when an item is added\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab calling program can store this and get access later\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab storing some location information in the Element\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab this will be related to the implementation of the APQ\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab need to maintain this consistently through operations\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 ADT\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 add(key, item)}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab add a new item into the priority queue with a certain priority, and return its element in the APQ\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 min()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab return the value with the minimum key\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 remove_min()}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab remove and return the value with the minimum key\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 is_empty()}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 length()}\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 update_key(element, new_key)}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab update the key of an element and rebalance the APQ\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 get_key(element)}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab get the key of an element\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 remove(element)}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab remove the element from the APQ and rebalance\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Element:\line
    """ A key, value and index. """\line
    def __init__(self, k, v, i):\line
        self._key = k\line
        self._value = v\line
        self._index = i\line
\line
    def __eq__(self, other):\line
        return self._key == other._key\line
\line
    def __lt__(self, other):\line
        return self._key < other._key\line
\line
    def _wipe(self): self._key = None\line
        self._value = None\line
        self._index = None\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Unsorted List Implementation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 add(key, item)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab create the Element, append to the list, return the Element\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(1)*\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 min()}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab search the list for the Element with minimum key, return (key, value)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(n)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 remove_min()}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab search the list for Element with minimum key, swap it with last place, pop, return (key, value)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(n)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 update_key(element, new_key)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab update the Element's key\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(1)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 get_key(element)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab return the Element's key\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(1)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 remove(element)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab use Element's index to swap it into last place, pop, return popped (key, value)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(1)*\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Array-Based Heap Implementation\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 add(key, item)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab create the Element, append to the list, bubble up, return Element\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(log n)*\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 min()}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab return (key, value) of first Element in the list\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(1)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 remove_min()}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab swap first Element with last place, pop, bubble down from top, return (key, value) of removed Element\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(log n)*\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 update_key(element, new_key)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab update the Element's key, compare to parent, either bubble up or down\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(log n)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 get_key(element)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab return the Element's key\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(1)\sa180\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\f1 remove(element)}\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab use Element's index to swap it into last place, pop, bubble up or down, return popped (key, value)\par}
{\pard \ql \f0 \sa180 \li720 \fi-360 \endash \tx360\tab O(log n)*\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Also, whenever we swap two elements, we have to update the index values in the Elements.\par}
}
