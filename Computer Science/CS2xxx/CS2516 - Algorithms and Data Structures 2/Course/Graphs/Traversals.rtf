{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Graph Traversals\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The standard traversal is to visit all the vertices that can be reached from some starting vertex.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 We'll start with two basic ones:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab depth-first search\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab breadth-first search\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Depth-first Search\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Go as far as you can\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Whenever you hit a dead end, retrace your steps until a new path is available to you\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In longer terms:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab mark the first vertex\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab choose an edge, and move along it to the opposite vertex \u8211- mark it\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab don't visit any vertex you've visited before\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab when there are no unmarked vertices adjacent to the current one:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab backtrack to the vertex before the current one and try the next edge from there\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab when we are back at the first vertex and there are no more edges we can try:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab stop\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pseudocode (for a recursive implementation):\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 depthfirstsearch(graph, v):\line
    mark v\line
    for each edge (v, w)\line
        if w has not been marked\line
            mark w\line
            depthfirstsearch(graph, w)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab relies on the marking existing outside of the recursion\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This algorithm is quite efficient, but gives strange paths. You could implement DFS non-recursively using a stack.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Properties\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab The set of vertices marked in DFS is the connected component of G containing v.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab The set of marked vertices and the edges that led to them in DFS form a rooted spanning tree of the connected component, rooted at v.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab The worst-case running time of DFS is O(n + m), where n is the number of vertices and m is the number of edges.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Edges in a Graph\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For a simple undirected graph with n vertices, there are {\f1 0 + 1 + \u8230? + (n-1)} edges (as long as no vertex can be linked to itself). This is equal to {\f1 0.5 * (n - 1) * n}, which is O(n^2).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Breadth-first Search\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Depth-first search is easy to implement and is fast, but some vertices close to the start vertex are not discovered until late in the traversal. The resultant tree has very long paths to some vertices.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Breadth-first search says to visit all vertices that are 1 hop away from the start vertex, then all that are 2 away, and so on.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The resultant tree will contain the shortest path to each vertex.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Python code\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Properties\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Should get into the habit of proving these things\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Since the number of edges could be O(n^2), this and depth-first search could be O(n^2), depending on the graph.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Directed Graphs\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Use an ordered pair for each edge instead of a set\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Now the max number of edges is {\f1 n * (n-1)}, because there can now be two edges between each pair (one in each direction)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Traversals\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Have to change the definition of connected component now\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Transitive Closure of a Graph\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab The vertices you can get to from each vertex\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Computing Transitive Closure\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab could also use breadth-first search (doesn't matter if it's an undirected graph)\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 V2 (Floyd-Warshall Algorithm to compute the transitive closure)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab This looks complicated but we'll see why it's useful later with a certain problem\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Adding intermediate vertices that are allowed in the path with each iteration\sa180\par}
}
